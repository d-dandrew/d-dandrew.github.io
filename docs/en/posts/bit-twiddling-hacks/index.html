<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="D_DAndrew">
    <meta name="description" content="A new coder">
    <meta name="keywords" content="blog,developer,games,sci-fi,personal">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Bit Twiddling Hacks"/>
<meta name="twitter:description" content="By Sean Eron Anderson seander@cs.stanford.edu
Individually, the code snippets here are in the public domain (unless otherwise noted) — feel free to use them however you please. The aggregate collection and descriptions are © 1997-2005 Sean Eron Anderson. The code and descriptions are distributed in the hope that they will be useful, but WITHOUT ANY WARRANTY and without even the implied warranty of merchantability or fitness for a particular purpose."/>

    <meta property="og:title" content="Bit Twiddling Hacks" />
<meta property="og:description" content="By Sean Eron Anderson seander@cs.stanford.edu
Individually, the code snippets here are in the public domain (unless otherwise noted) — feel free to use them however you please. The aggregate collection and descriptions are © 1997-2005 Sean Eron Anderson. The code and descriptions are distributed in the hope that they will be useful, but WITHOUT ANY WARRANTY and without even the implied warranty of merchantability or fitness for a particular purpose." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://d-dandrew.github.io/en/posts/bit-twiddling-hacks/" />
<meta property="article:published_time" content="2018-02-21T00:00:00&#43;00:00"/>
<meta property="article:modified_time" content="2018-02-21T00:00:00&#43;00:00"/>




    
      <base href="https://d-dandrew.github.io/en/posts/bit-twiddling-hacks/">
    
    <title>
  Bit Twiddling Hacks · ddandrew&#39;s home site
</title>

    
      <link rel="canonical" href="https://d-dandrew.github.io/en/posts/bit-twiddling-hacks/">
    

    <link rel="stylesheet" href=https://fonts.googleapis.com/css?family&#61;Lato:400,700%7CMerriweather:300,700%7CSource&#43;Code&#43;Pro:400,700 integrity=sha384-UZhG5WipmU6WiF5wop3ssl1Wg0UEzv74OlREk8MniXxZPYlH4srr78D5Oye4n1xa>
    <link rel="stylesheet" href=https://use.fontawesome.com/releases/v5.3.1/css/all.css integrity=sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt&#43;Y8vEf7N7fWAU crossorigin="anonymous" />
    <link rel="stylesheet" href=https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css integrity=sha384-eYUmD1FFkORGrJdmrD37Z5LUEElTzF32&#43;UI3jkzt7C1vpmUGo5KOVvb3Z5LeZHky crossorigin="anonymous" />
    
    
      
      
      <link rel="stylesheet" href="https://d-dandrew.github.io/css/coder.min.28d751104f30c16da1aa1bb04015cbe662cacfe0d1b01af4f2240ad58580069c.css" integrity="sha256-KNdREE8wwW2hqhuwQBXL5mLKz&#43;DRsBr08iQK1YWABpw=" crossorigin="anonymous" media="screen" />
    

    

    

    

    <link rel="icon" type="image/png" href="https://d-dandrew.github.io/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="https://d-dandrew.github.io/images/favicon-16x16.png" sizes="16x16">

    <meta name="generator" content="Hugo 0.54.0" />
  </head>

  <body class=" ">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://d-dandrew.github.io">
      ddandrew&#39;s home site
    </a>
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://d-dandrew.github.io/en/about/">About</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://d-dandrew.github.io/en/posts/">Blog</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://d-dandrew.github.io/en/projects/">Projects</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://d-dandrew.github.io/en/contact/">Contact me</a>
          </li>
        
      
      
        
        
        
          
            
              <li class="navigation-item menu-separator">
                <span>|</span>
              </li>
              
            
            <li class="navigation-item">
              <a href="https://d-dandrew.github.io/">中文</a>
            </li>
          
        
          
        
      
    </ul>
  </section>
</nav>


      <div class="content">
        
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">Bit Twiddling Hacks</h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fas fa-calendar"></i>
              <time datetime='2018-02-21T00:00:00Z'>
                February 21, 2018
              </time>
            </span>
            <span class="reading-time">
              <i class="fas fa-clock"></i>
              71 minutes read
            </span>
          </div>
          <div class="categories">
  <i class="fas fa-folder"></i>
    <a href="https://d-dandrew.github.io/en/categories/development/">Development</a></div>

          <div class="tags">
  <i class="fas fa-tag"></i>
    <a href="https://d-dandrew.github.io/en/tags/development/">Development</a>
      <span class="separator">•</span>
    <a href="https://d-dandrew.github.io/en/tags/hack/">hack</a></div>

        </div>
      </header>

      <div>
        

<h3 id="by-sean-eron-anderson">By Sean Eron Anderson</h3>

<p>seander@cs.stanford.edu</p>

<p>Individually, the <strong>code snippets here are in the public domain</strong> (unless otherwise noted) — feel free to use them however you please. The aggregate collection and descriptions are © 1997-2005 Sean Eron Anderson. The code and descriptions are distributed in the hope that they will be useful, but <strong>WITHOUT ANY WARRANTY</strong> and without even the implied warranty of merchantability or fitness for a particular purpose. As of May 5, 2005, all the code has been tested thoroughly. Thousands of people have read it. Moreover, <a href="http://www-2.cs.cmu.edu/~bryant/">Professor Randal Bryant</a>, the Dean of Computer Science at Carnegie Mellon University, has personally tested almost everything with his <a href="http://www-2.cs.cmu.edu/~uclid/">Uclid code verification system</a>. What he hasn&rsquo;t tested, I have checked against all possible inputs on a 32-bit machine. <strong>To the first person to inform me of a legitimate bug in the code, I&rsquo;ll pay a bounty of US$10 (by check or Paypal)</strong>. If directed to a charity, I&rsquo;ll pay US$20.</p>

<h3 id="contents">Contents</h3>

<ul>
<li><a href="#OperationCounting">About the operation counting methodology</a></li>
<li><a href="#CopyIntegerSign">Compute the sign of an integer</a></li>
<li><a href="#DetectOppositeSigns">Detect if two integers have opposite signs</a></li>
<li><a href="#IntegerAbs">Compute the integer absolute value (abs) without branching</a></li>
<li><a href="#IntegerMinOrMax">Compute the minimum (min) or maximum (max) of two integers without branching</a></li>
<li><a href="#DetermineIfPowerOf2">Determining if an integer is a power of 2</a></li>
<li>Sign extending

<ul>
<li><a href="#FixedSignExtend">Sign extending from a constant bit-width</a></li>
<li><a href="#VariableSignExtend">Sign extending from a variable bit-width</a></li>
<li><a href="#VariableSignExtendRisky">Sign extending from a variable bit-width in 3 operations</a></li>
</ul></li>
<li><a href="#ConditionalSetOrClearBitsWithoutBranching">Conditionally set or clear bits without branching</a></li>
<li><a href="#ConditionalNegate">Conditionally negate a value without branching</a></li>
<li><a href="#MaskedMerge">Merge bits from two values according to a mask</a></li>
<li>Counting bits set

<ul>
<li><a href="#CountBitsSetNaive">Counting bits set, naive way</a></li>
<li><a href="#CountBitsSetTable">Counting bits set by lookup table</a></li>
<li><a href="#CountBitsSetKernighan">Counting bits set, Brian Kernighan&rsquo;s way</a></li>
<li><a href="#CountBitsSet64">Counting bits set in 14, 24, or 32-bit words using 64-bit instructions</a></li>
<li><a href="#CountBitsSetParallel">Counting bits set, in parallel</a></li>
<li><a href="#CountBitsFromMSBToPos">Count bits set (rank) from the most-significant bit upto a given position</a></li>
<li><a href="#SelectPosFromMSBRank">Select the bit position (from the most-significant bit) with the given count (rank)</a></li>
</ul></li>
<li>Computing parity (1 if an odd number of bits set, 0 otherwise)

<ul>
<li><a href="#ParityNaive">Compute parity of a word the naive way</a></li>
<li><a href="#ParityLookupTable">Compute parity by lookup table</a></li>
<li><a href="#ParityWith64Bits">Compute parity of a byte using 64-bit multiply and modulus division</a></li>
<li><a href="#ParityMultiply">Compute parity of word with a multiply</a></li>
<li><a href="#ParityParallel">Compute parity in parallel</a></li>
</ul></li>
<li>Swapping Values

<ul>
<li><a href="#SwappingValuesSubAdd">Swapping values with subtraction and addition</a></li>
<li><a href="#SwappingValuesXOR">Swapping values with XOR</a></li>
<li><a href="#SwappingBitsXOR">Swapping individual bits with XOR</a></li>
</ul></li>
<li>Reversing bit sequences

<ul>
<li><a href="#BitReverseObvious">Reverse bits the obvious way</a></li>
<li><a href="#BitReverseTable">Reverse bits in word by lookup table</a></li>
<li><a href="#ReverseByteWith64BitsDiv">Reverse the bits in a byte with 3 operations (64-bit multiply and modulus division)</a></li>
<li><a href="#ReverseByteWith64Bits">Reverse the bits in a byte with 4 operations (64-bit multiply, no division)</a></li>
<li><a href="#ReverseByteWith32Bits">Reverse the bits in a byte with 7 operations (no 64-bit, only 32)</a></li>
<li><a href="#ReverseParallel">Reverse an N-bit quantity in parallel with 5 * lg(N) operations</a></li>
</ul></li>
<li>Modulus division (aka computing <em>remainders</em>)

<ul>
<li><a href="#ModulusDivisionEasy">Computing modulus division by 1 &lt;&lt; s without a division operation (obvious)</a></li>
<li><a href="#ModulusDivision">Computing modulus division by (1 &lt;&lt; s) - 1 without a division operation</a></li>
<li><a href="#ModulusDivisionParallel">Computing modulus division by (1 &lt;&lt; s) - 1 in parallel without a division operation</a></li>
</ul></li>
<li>Finding integer log base 2 of an integer (aka the position of the highest bit set)

<ul>
<li><a href="#IntegerLogObvious">Find the log base 2 of an integer with the MSB N set in O(N) operations (the obvious way)</a></li>
<li><a href="#IntegerLogIEEE64Float">Find the integer log base 2 of an integer with an 64-bit IEEE float</a></li>
<li><a href="#IntegerLogLookup">Find the log base 2 of an integer with a lookup table</a></li>
<li><a href="#IntegerLog">Find the log base 2 of an N-bit integer in O(lg(N)) operations</a></li>
<li><a href="#IntegerLogDeBruijn">Find the log base 2 of an N-bit integer in O(lg(N)) operations with multiply and lookup</a></li>
</ul></li>
<li><a href="#IntegerLog10">Find integer log base 10 of an integer</a></li>
<li><a href="#IntegerLog10Obvious">Find integer log base 10 of an integer the obvious way</a></li>
<li><a href="#IntegerLogFloat">Find integer log base 2 of a 32-bit IEEE float</a></li>
<li><a href="#IntegerLogRootFloat">Find integer log base 2 of the pow(2, r)-root of a 32-bit IEEE float (for unsigned integer r)</a></li>
<li>Counting consecutive trailing zero bits (or finding bit indices)

<ul>
<li><a href="#ZerosOnRightLinear">Count the consecutive zero bits (trailing) on the right linearly</a></li>
<li><a href="#ZerosOnRightParallel">Count the consecutive zero bits (trailing) on the right in parallel</a></li>
<li><a href="#ZerosOnRightBinSearch">Count the consecutive zero bits (trailing) on the right by binary search</a></li>
<li><a href="#ZerosOnRightFloatCast">Count the consecutive zero bits (trailing) on the right by casting to a float</a></li>
<li><a href="#ZerosOnRightModLookup">Count the consecutive zero bits (trailing) on the right with modulus division and lookup</a></li>
<li><a href="#ZerosOnRightMultLookup">Count the consecutive zero bits (trailing) on the right with multiply and lookup</a></li>
</ul></li>
<li><a href="#RoundUpPowerOf2Float">Round up to the next highest power of 2 by float casting</a></li>
<li><a href="#RoundUpPowerOf2">Round up to the next highest power of 2</a></li>
<li>Interleaving bits (aka computing <em>Morton Numbers</em>)

<ul>
<li><a href="#InterleaveTableObvious">Interleave bits the obvious way</a></li>
<li><a href="#InterleaveTableLookup">Interleave bits by table lookup</a></li>
<li><a href="#Interleave64bitOps">Interleave bits with 64-bit multiply</a></li>
<li><a href="#InterleaveBMN">Interleave bits by Binary Magic Numbers</a></li>
</ul></li>
<li>Testing for ranges of bytes in a word (and counting occurances found)

<ul>
<li><a href="#ZeroInWord">Determine if a word has a zero byte</a></li>
<li><a href="#ValueInWord">Determine if a word has a byte equal to n</a></li>
<li><a href="#HasLessInWord">Determine if a word has byte less than n</a></li>
<li><a href="#HasMoreInWord">Determine if a word has a byte greater than n</a></li>
<li><a href="#HasBetweenInWord">Determine if a word has a byte between m and n</a></li>
</ul></li>
<li><a href="#NextBitPermutation">Compute the lexicographically next bit permutation</a></li>
</ul>

<hr />

<h3 id="about-the-operation-counting-methodology">About the operation counting methodology</h3>

<p>When totaling the number of operations for algorithms here, any C operator is counted as one operation. Intermediate assignments, which need not be written to RAM, are not counted. Of course, this operation counting approach only serves as an approximation of the actual number of machine instructions and CPU time. All operations are assumed to take the same amount of time, which is not true in reality, but CPUs have been heading increasingly in this direction over time. There are many nuances that determine how fast a system will run a given sample of code, such as cache sizes, memory bandwidths, instruction sets, etc. In the end, benchmarking is the best way to determine whether one method is really faster than another, so consider the techniques below as possibilities to test on your target architecture.</p>

<hr />

<h3 id="compute-the-sign-of-an-integer">Compute the sign of an integer</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">int</span> v;      <span style="color:#007f7f">// we want to find the sign of v
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">int</span> sign;   <span style="color:#007f7f">// the result goes here  
</span><span style="color:#007f7f"></span>
<span style="color:#007f7f">// CHAR_BIT is the number of bits per byte (normally 8).
</span><span style="color:#007f7f"></span>sign = -(v &lt; <span style="color:#ff0;font-weight:bold">0</span>);  <span style="color:#007f7f">// if v &lt; 0 then -1, else 0.
</span><span style="color:#007f7f">// or, to avoid branching on CPUs with flag registers (IA32):
</span><span style="color:#007f7f"></span>sign = -(<span style="color:#fff;font-weight:bold">int</span>)((<span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span>)((<span style="color:#fff;font-weight:bold">int</span>)v) &gt;&gt; (<span style="color:#fff;font-weight:bold">sizeof</span>(<span style="color:#fff;font-weight:bold">int</span>) * CHAR_BIT - <span style="color:#ff0;font-weight:bold">1</span>));
<span style="color:#007f7f">// or, for one less instruction (but not portable):
</span><span style="color:#007f7f"></span>sign = v &gt;&gt; (<span style="color:#fff;font-weight:bold">sizeof</span>(<span style="color:#fff;font-weight:bold">int</span>) * CHAR_BIT - <span style="color:#ff0;font-weight:bold">1</span>);  </code></pre></div>
<p>The last expression above evaluates to sign = v &gt;&gt; 31 for 32-bit integers. This is one operation faster than the obvious way, sign = -(v &lt; 0). This trick works because when signed integers are shifted right, the value of the far left bit is copied to the other bits. The far left bit is 1 when the value is negative and 0 otherwise; all 1 bits gives -1. Unfortunately, this behavior is architecture-specific.</p>

<p>Alternatively, if you prefer the result be either -1 or +1, then use:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">sign = +<span style="color:#ff0;font-weight:bold">1</span> | (v &gt;&gt; (<span style="color:#fff;font-weight:bold">sizeof</span>(<span style="color:#fff;font-weight:bold">int</span>) * CHAR_BIT - <span style="color:#ff0;font-weight:bold">1</span>));  // <span style="color:#fff;font-weight:bold">if</span> v &lt; <span style="color:#ff0;font-weight:bold">0</span> then -<span style="color:#ff0;font-weight:bold">1</span>, <span style="color:#fff;font-weight:bold">else</span> +<span style="color:#ff0;font-weight:bold">1</span></code></pre></div>
<p>On the other hand, if you prefer the result be either -1, 0, or +1, then use:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">sign = (v != <span style="color:#ff0;font-weight:bold">0</span>) | -(<span style="color:#fff;font-weight:bold">int</span>)((<span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span>)((<span style="color:#fff;font-weight:bold">int</span>)v) &gt;&gt; (<span style="color:#fff;font-weight:bold">sizeof</span>(<span style="color:#fff;font-weight:bold">int</span>) * CHAR_BIT - <span style="color:#ff0;font-weight:bold">1</span>));
<span style="color:#007f7f">// Or, for more speed but less portability:
</span><span style="color:#007f7f"></span>sign = (v != <span style="color:#ff0;font-weight:bold">0</span>) | (v &gt;&gt; (<span style="color:#fff;font-weight:bold">sizeof</span>(<span style="color:#fff;font-weight:bold">int</span>) * CHAR_BIT - <span style="color:#ff0;font-weight:bold">1</span>));  <span style="color:#007f7f">// -1, 0, or +1
</span><span style="color:#007f7f">// Or, for portability, brevity, and (perhaps) speed:
</span><span style="color:#007f7f"></span>sign = (v &gt; <span style="color:#ff0;font-weight:bold">0</span>) - (v &lt; <span style="color:#ff0;font-weight:bold">0</span>); // -<span style="color:#ff0;font-weight:bold">1</span>, <span style="color:#ff0;font-weight:bold">0</span>, or +<span style="color:#ff0;font-weight:bold">1</span></code></pre></div>
<p>If instead you want to know if something is non-negative, resulting in +1 or else 0, then use:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">sign = <span style="color:#ff0;font-weight:bold">1</span> ^ ((<span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span>)v &gt;&gt; (<span style="color:#fff;font-weight:bold">sizeof</span>(<span style="color:#fff;font-weight:bold">int</span>) * CHAR_BIT - <span style="color:#ff0;font-weight:bold">1</span>)); // <span style="color:#fff;font-weight:bold">if</span> v &lt; <span style="color:#ff0;font-weight:bold">0</span> then <span style="color:#ff0;font-weight:bold">0</span>, <span style="color:#fff;font-weight:bold">else</span> <span style="color:#ff0;font-weight:bold">1</span></code></pre></div>
<p>Caveat: On March 7, 2003, Angus Duggan pointed out that the 1989 ANSI C specification leaves the result of signed right-shift implementation-defined, so on some systems this hack might not work. For greater portability, Toby Speight suggested on September 28, 2005 that CHAR_BIT be used here and throughout rather than assuming bytes were 8 bits long. Angus recommended the more portable versions above, involving casting on March 4, 2006. <a href="http://rpg-314.blogspot.com/">Rohit Garg</a> suggested the version for non-negative integers on September 12, 2009.</p>

<hr />

<h3 id="detect-if-two-integers-have-opposite-signs">Detect if two integers have opposite signs</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">int</span> x, y;               <span style="color:#007f7f">// input values to compare signs
</span><span style="color:#007f7f"></span>
<span style="color:#fff;font-weight:bold">bool</span> f = ((x ^ y) &lt; <span style="color:#ff0;font-weight:bold">0</span>); // <span style="color:#fff;font-weight:bold">true</span> iff x and y have opposite signs</code></pre></div>
<p>Manfred Weis suggested I add this entry on November 26, 2009.</p>

<hr />

<h3 id="compute-the-integer-absolute-value-abs-without-branching">Compute the integer absolute value (abs) without branching</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">int</span> v;           <span style="color:#007f7f">// we want to find the absolute value of v
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> r;  <span style="color:#007f7f">// the result goes here
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">int</span> <span style="color:#fff;font-weight:bold">const</span> mask = v &gt;&gt; <span style="color:#fff;font-weight:bold">sizeof</span>(<span style="color:#fff;font-weight:bold">int</span>) * CHAR_BIT - <span style="color:#ff0;font-weight:bold">1</span>;

r = (v + mask) ^ mask;</code></pre></div>
<p>Patented variation:</p>

<p><code>r = (v ^ mask) - mask;</code></p>

<p>Some CPUs don&rsquo;t have an integer absolute value instruction (or the compiler fails to use them). On machines where branching is expensive, the above expression can be faster than the obvious approach, r = (v &lt; 0) ? -(unsigned)v : v, even though the number of operations is the same.</p>

<p>On March 7, 2003, Angus Duggan pointed out that the 1989 ANSI C specification leaves the result of signed right-shift implementation-defined, so on some systems this hack might not work. I&rsquo;ve read that ANSI C does not require values to be represented as two&rsquo;s complement, so it may not work for that reason as well (on a diminishingly small number of old machines that still use one&rsquo;s complement). On March 14, 2004, Keith H. Duggar sent me the patented variation above; it is superior to the one I initially came up with, <code>r=(+1|(v&gt;&gt;(sizeof(int)*CHAR_BIT-1)))*v</code>, because a multiply is not used. Unfortunately, this method has been <a href="http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;p=1&amp;u=/netahtml/search-adv.htm&amp;r=1&amp;f=G&amp;l=50&amp;d=ptxt&amp;S1=6073150&amp;OS=6073150&amp;RS=6073150">patented</a> in the USA on June 6, 2000 by Vladimir Yu Volkonsky and assigned to <a href="http://www.sun.com/">Sun Microsystems</a>. On August 13, 2006, Yuriy Kaminskiy told me that the patent is likely invalid because the method was published well before the patent was even filed, such as in <a href="http://www.goof.com/pcg/doc/pentopt.txt">How to Optimize for the Pentium Processor</a> by Agner Fog, dated November, 9, 1996. Yuriy also mentioned that this document was translated to Russian in 1997, which Vladimir could have read. Moreover, the Internet Archive also has an old <a href="http://web.archive.org/web/19961201174141/www.x86.org/ftp/articles/pentopt/PENTOPT.TXT">link</a> to it. On January 30, 2007, Peter Kankowski shared with me an <a href="http://smallcode.weblogs.us/2007/01/31/microsoft-probably-uses-the-abs-function-patented-by-sun/">abs version</a> he discovered that was inspired by Microsoft&rsquo;s Visual C++ compiler output. It is featured here as the primary solution. On December 6, 2007, Hai Jin complained that the result was signed, so when computing the abs of the most negative value, it was still negative. On April 15, 2008 Andrew Shapira pointed out that the obvious approach could overflow, as it lacked an (unsigned) cast then; for maximum portability he suggested <code>(v &lt; 0) ? (1 + ((unsigned)(-1-v))) : (unsigned)v</code>. But citing the ISO C99 spec on July 9, 2008, Vincent Lefèvre convinced me to remove it becasue even on non-2s-complement machines -(unsigned)v will do the right thing. The evaluation of -(unsigned)v first converts the negative value of v to an unsigned by adding 2<strong>N, yielding a 2s complement representation of v&rsquo;s value that I&rsquo;ll call U. Then, U is negated, giving the desired result, -U = 0 - U = 2</strong>N - U = 2<strong>N - (v+2</strong>N) = -v = abs(v).</p>

<hr />

<h3 id="compute-the-minimum-min-or-maximum-max-of-two-integers-without-branching">Compute the minimum (min) or maximum (max) of two integers without branching</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">int</span> x;  <span style="color:#007f7f">// we want to find the minimum of x and y
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">int</span> y;
<span style="color:#fff;font-weight:bold">int</span> r;  <span style="color:#007f7f">// the result goes here
</span><span style="color:#007f7f"></span>
r = y ^ ((x ^ y) &amp; -(x &lt; y)); // min(x, y)</code></pre></div>
<p>On some rare machines where branching is very expensive and no condition move instructions exist, the above expression might be faster than the obvious approach, <code>r = (x &lt; y) ? x : y</code>, even though it involves two more instructions. (Typically, the obvious approach is best, though.) It works because <code>if x &lt; y, then -(x &lt; y)</code> will be all ones, so <code>r = y ^ (x ^ y) &amp; ~0 = y ^ x ^ y = x</code>. Otherwise, <code>if x &gt;= y, then -(x &lt; y)</code> will be all zeros, so <code>r = y ^ ((x ^ y) &amp; 0) = y</code>. On some machines, evaluating <code>(x &lt; y)</code> as 0 or 1 requires a branch instruction, so there may be no advantage.</p>

<p>To find the maximum, use:</p>

<p><code>r = x ^ ((x ^ y) &amp; -(x &lt; y)); // max(x, y)</code></p>

<h4 id="quick-and-dirty-versions">Quick and dirty versions:</h4>

<p>If you know that INT_MIN &lt;= x - y &lt;= INT_MAX, then you can use the following, which are faster because (x - y) only needs to be evaluated once.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">r = y + ((x - y) &amp; ((x - y) &gt;&gt; (<span style="color:#fff;font-weight:bold">sizeof</span>(<span style="color:#fff;font-weight:bold">int</span>) * CHAR_BIT - <span style="color:#ff0;font-weight:bold">1</span>))); <span style="color:#007f7f">// min(x, y)
</span><span style="color:#007f7f"></span>r = x - ((x - y) &amp; ((x - y) &gt;&gt; (<span style="color:#fff;font-weight:bold">sizeof</span>(<span style="color:#fff;font-weight:bold">int</span>) * CHAR_BIT - <span style="color:#ff0;font-weight:bold">1</span>))); // max(x, y)</code></pre></div>
<p>Note that the 1989 ANSI C specification doesn&rsquo;t specify the result of signed right-shift, so these aren&rsquo;t portable. If exceptions are thrown on overflows, then the values of x and y should be unsigned or cast to unsigned for the subtractions to avoid unnecessarily throwing an exception, however the right-shift needs a signed operand to produce all one bits when negative, so cast to signed there.</p>

<p>On March 7, 2003, Angus Duggan pointed out the right-shift portability issue. On May 3, 2005, Randal E. Bryant alerted me to the need for the precondition, INT_MIN &lt;= x - y &lt;= INT_MAX, and suggested the non-quick and dirty version as a fix. Both of these issues concern only the quick and dirty version. Nigel Horspoon observed on July 6, 2005 that gcc produced the same code on a Pentium as the obvious solution because of how it evaluates (x &lt; y). On July 9, 2008 Vincent Lefèvre pointed out the potential for overflow exceptions with subtractions in r = y + ((x - y) &amp; -(x &lt; y)), which was the previous version. Timothy B. Terriberry suggested using xor rather than add and subract to avoid casting and the risk of overflows on June 2, 2009.</p>

<hr />

<h3 id="determining-if-an-integer-is-a-power-of-2">Determining if an integer is a power of 2</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> v; <span style="color:#007f7f">// we want to see if v is a power of 2
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">bool</span> f;         <span style="color:#007f7f">// the result goes here
</span><span style="color:#007f7f"></span>
f = (v &amp; (v - <span style="color:#ff0;font-weight:bold">1</span>)) == <span style="color:#ff0;font-weight:bold">0</span>;</code></pre></div>
<p>Note that 0 is incorrectly considered a power of 2 here. To remedy this, use:</p>

<p><code>f = v &amp;&amp; !(v &amp; (v - 1));</code></p>

<hr />

<h3 id="sign-extending-from-a-constant-bit-width">Sign extending from a constant bit-width</h3>

<p>Sign extension is automatic for built-in types, such as chars and ints. But suppose you have a signed two&rsquo;s complement number, x, that is stored using only b bits. Moreover, suppose you want to convert x to an int, which has more than b bits. A simple copy will work if x is positive, but if negative, the sign must be extended. For example, if we have only 4 bits to store a number, then -3 is represented as 1101 in binary. If we have 8 bits, then -3 is 11111101. The most-significant bit of the 4-bit representation is replicated sinistrally to fill in the destination when we convert to a representation with more bits; this is sign extending. In C, sign extension from a constant bit-width is trivial, since bit fields may be specified in structs or unions. For example, to convert from 5 bits to an full integer:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">int</span> x; <span style="color:#007f7f">// convert this from using 5 bits to a full int
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">int</span> r; <span style="color:#007f7f">// resulting sign extended number goes here
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">struct</span> {<span style="color:#fff;font-weight:bold">signed</span> <span style="color:#fff;font-weight:bold">int</span> x:<span style="color:#ff0;font-weight:bold">5</span>;} s;
r = s.x = x;</code></pre></div>
<p>The following is a C++ template function that uses the same language feature to convert from B bits in one operation (though the compiler is generating more, of course).</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">template &lt;<span style="color:#fff;font-weight:bold">typename</span> T, <span style="color:#fff;font-weight:bold">unsigned</span> B&gt;
<span style="color:#fff;font-weight:bold">inline</span> T signextend(<span style="color:#fff;font-weight:bold">const</span> T x)
{
  <span style="color:#fff;font-weight:bold">struct</span> {T x:B;} s;
  <span style="color:#fff;font-weight:bold">return</span> s.x = x;
}

<span style="color:#fff;font-weight:bold">int</span> r = signextend&lt;<span style="color:#fff;font-weight:bold">signed</span> <span style="color:#fff;font-weight:bold">int</span>,<span style="color:#ff0;font-weight:bold">5</span>&gt;(x);  // sign extend <span style="color:#ff0;font-weight:bold">5</span> bit number x to r</code></pre></div>
<p>John Byrd caught a typo in the code (attributed to html formatting) on May 2, 2005. On March 4, 2006, Pat Wood pointed out that the ANSI C standard requires that the bitfield have the keyword &ldquo;signed&rdquo; to be signed; otherwise, the sign is undefined.</p>

<hr />

<h3 id="sign-extending-from-a-variable-bit-width">Sign extending from a variable bit-width</h3>

<p>Sometimes we need to extend the sign of a number but we don&rsquo;t know a priori the number of bits, b, in which it is represented. (Or we could be programming in a language like Java, which lacks bitfields.)</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">unsigned</span> b; <span style="color:#007f7f">// number of bits representing the number in x
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">int</span> x;      <span style="color:#007f7f">// sign extend this b-bit number to r
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">int</span> r;      <span style="color:#007f7f">// resulting sign-extended number
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">int</span> <span style="color:#fff;font-weight:bold">const</span> m = <span style="color:#ff0;font-weight:bold">1U</span> &lt;&lt; (b - <span style="color:#ff0;font-weight:bold">1</span>); <span style="color:#007f7f">// mask can be pre-computed if b is fixed
</span><span style="color:#007f7f"></span>
x = x &amp; ((<span style="color:#ff0;font-weight:bold">1U</span> &lt;&lt; b) - <span style="color:#ff0;font-weight:bold">1</span>);  <span style="color:#007f7f">// (Skip this if bits in x above position b are already zero.)
</span><span style="color:#007f7f"></span>r = (x ^ m) - m;</code></pre></div>
<p>The code above requires four operations, but when the bitwidth is a constant rather than variable, it requires only two fast operations, assuming the upper bits are already zeroes.</p>

<p>A slightly faster but less portable method that doesn&rsquo;t depend on the bits in x above position b being zero is:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">int</span> <span style="color:#fff;font-weight:bold">const</span> m = CHAR_BIT * <span style="color:#fff;font-weight:bold">sizeof</span>(x) - b;
r = (x &lt;&lt; m) &gt;&gt; m;</code></pre></div>
<p>Sean A. Irvine suggested that I add sign extension methods to this page on June 13, 2004, and he provided <code>m = (1 &lt;&lt; (b - 1)) - 1; r = -(x &amp; ~m) | x;</code> as a starting point from which I optimized to get <code>m = 1U &lt;&lt; (b - 1); r = -(x &amp; m) | x</code>. But then on May 11, 2007, Shay Green suggested the version above, which requires one less operation than mine. Vipin Sharma suggested I add a step to deal with situations where x had possible ones in bits other than the b bits we wanted to sign-extend on Oct. 15, 2008. On December 31, 2009 Chris Pirazzi suggested I add the faster version, which requires two operations for constant bit-widths and three for variable widths.</p>

<hr />

<h3 id="sign-extending-from-a-variable-bit-width-in-3-operations">Sign extending from a variable bit-width in 3 operations</h3>

<p>The following may be slow on some machines, due to the effort required for multiplication and division. This version is 4 operations. If you know that your initial bit-width, b, is greater than 1, you might do this type of sign extension in 3 operations by using <code>r = (x * multipliers[b]) / multipliers[b]</code>, which requires only one array lookup.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">unsigned</span> b; <span style="color:#007f7f">// number of bits representing the number in x
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">int</span> x;      <span style="color:#007f7f">// sign extend this b-bit number to r
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">int</span> r;      <span style="color:#007f7f">// resulting sign-extended number
</span><span style="color:#007f7f"></span><span style="color:#0f0;font-weight:bold">#define M(B) (1U &lt;&lt; ((sizeof(x) * CHAR_BIT) - B)) </span><span style="color:#007f7f">// CHAR_BIT=bits/byte
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">int</span> <span style="color:#fff;font-weight:bold">const</span> multipliers[] =
{
  <span style="color:#ff0;font-weight:bold">0</span>,     M(<span style="color:#ff0;font-weight:bold">1</span>),  M(<span style="color:#ff0;font-weight:bold">2</span>),  M(<span style="color:#ff0;font-weight:bold">3</span>),  M(<span style="color:#ff0;font-weight:bold">4</span>),  M(<span style="color:#ff0;font-weight:bold">5</span>),  M(<span style="color:#ff0;font-weight:bold">6</span>),  M(<span style="color:#ff0;font-weight:bold">7</span>),
  M(<span style="color:#ff0;font-weight:bold">8</span>),  M(<span style="color:#ff0;font-weight:bold">9</span>),  M(<span style="color:#ff0;font-weight:bold">10</span>), M(<span style="color:#ff0;font-weight:bold">11</span>), M(<span style="color:#ff0;font-weight:bold">12</span>), M(<span style="color:#ff0;font-weight:bold">13</span>), M(<span style="color:#ff0;font-weight:bold">14</span>), M(<span style="color:#ff0;font-weight:bold">15</span>),
  M(<span style="color:#ff0;font-weight:bold">16</span>), M(<span style="color:#ff0;font-weight:bold">17</span>), M(<span style="color:#ff0;font-weight:bold">18</span>), M(<span style="color:#ff0;font-weight:bold">19</span>), M(<span style="color:#ff0;font-weight:bold">20</span>), M(<span style="color:#ff0;font-weight:bold">21</span>), M(<span style="color:#ff0;font-weight:bold">22</span>), M(<span style="color:#ff0;font-weight:bold">23</span>),
  M(<span style="color:#ff0;font-weight:bold">24</span>), M(<span style="color:#ff0;font-weight:bold">25</span>), M(<span style="color:#ff0;font-weight:bold">26</span>), M(<span style="color:#ff0;font-weight:bold">27</span>), M(<span style="color:#ff0;font-weight:bold">28</span>), M(<span style="color:#ff0;font-weight:bold">29</span>), M(<span style="color:#ff0;font-weight:bold">30</span>), M(<span style="color:#ff0;font-weight:bold">31</span>),
  M(<span style="color:#ff0;font-weight:bold">32</span>)
}; <span style="color:#007f7f">// (add more if using more than 64 bits)
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">int</span> <span style="color:#fff;font-weight:bold">const</span> divisors[] =
{
  <span style="color:#ff0;font-weight:bold">1</span>,    ~M(<span style="color:#ff0;font-weight:bold">1</span>),  M(<span style="color:#ff0;font-weight:bold">2</span>),  M(<span style="color:#ff0;font-weight:bold">3</span>),  M(<span style="color:#ff0;font-weight:bold">4</span>),  M(<span style="color:#ff0;font-weight:bold">5</span>),  M(<span style="color:#ff0;font-weight:bold">6</span>),  M(<span style="color:#ff0;font-weight:bold">7</span>),
  M(<span style="color:#ff0;font-weight:bold">8</span>),  M(<span style="color:#ff0;font-weight:bold">9</span>),  M(<span style="color:#ff0;font-weight:bold">10</span>), M(<span style="color:#ff0;font-weight:bold">11</span>), M(<span style="color:#ff0;font-weight:bold">12</span>), M(<span style="color:#ff0;font-weight:bold">13</span>), M(<span style="color:#ff0;font-weight:bold">14</span>), M(<span style="color:#ff0;font-weight:bold">15</span>),
  M(<span style="color:#ff0;font-weight:bold">16</span>), M(<span style="color:#ff0;font-weight:bold">17</span>), M(<span style="color:#ff0;font-weight:bold">18</span>), M(<span style="color:#ff0;font-weight:bold">19</span>), M(<span style="color:#ff0;font-weight:bold">20</span>), M(<span style="color:#ff0;font-weight:bold">21</span>), M(<span style="color:#ff0;font-weight:bold">22</span>), M(<span style="color:#ff0;font-weight:bold">23</span>),
  M(<span style="color:#ff0;font-weight:bold">24</span>), M(<span style="color:#ff0;font-weight:bold">25</span>), M(<span style="color:#ff0;font-weight:bold">26</span>), M(<span style="color:#ff0;font-weight:bold">27</span>), M(<span style="color:#ff0;font-weight:bold">28</span>), M(<span style="color:#ff0;font-weight:bold">29</span>), M(<span style="color:#ff0;font-weight:bold">30</span>), M(<span style="color:#ff0;font-weight:bold">31</span>),
  M(<span style="color:#ff0;font-weight:bold">32</span>)
}; <span style="color:#007f7f">// (add more for 64 bits)
</span><span style="color:#007f7f"></span><span style="color:#0f0;font-weight:bold">#undef M
</span><span style="color:#0f0;font-weight:bold"></span>r = (x * multipliers[b]) / divisors[b];

The following variation is not portable, but on architectures that employ an arithmetic right-shift, maintaining the sign, it should be fast.

<span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">int</span> s = -b; <span style="color:#007f7f">// OR:  sizeof(x) * CHAR_BIT - b;
</span><span style="color:#007f7f"></span>r = (x &lt;&lt; s) &gt;&gt; s;</code></pre></div>
<p>Randal E. Bryant pointed out a bug on May 3, 2005 in an earlier version (that used multipliers[] for divisors[]), where it failed on the case of x=1 and b=1.</p>

<hr />

<h3 id="conditionally-set-or-clear-bits-without-branching">Conditionally set or clear bits without branching</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">bool</span> f;         <span style="color:#007f7f">// conditional flag
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> m; <span style="color:#007f7f">// the bit mask 
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> w; <span style="color:#007f7f">// the word to modify:  if (f) w |= m; else w &amp;= ~m;
</span><span style="color:#007f7f"></span>
w ^= (-f ^ w) &amp; m;

<span style="color:#007f7f">// OR, for superscalar CPUs:
</span><span style="color:#007f7f"></span>w = (w &amp; ~m) | (-f &amp; m);</code></pre></div>
<p>On some architectures, the lack of branching can more than make up for what appears to be twice as many operations. For instance, informal speed tests on an AMD Athlon™ XP 2100+ indicated it was 5-10% faster. An Intel Core 2 Duo ran the superscalar version about 16% faster than the first. Glenn Slayden informed me of the first expression on December 11, 2003. Marco Yu shared the superscalar version with me on April 3, 2007 and alerted me to a typo 2 days later.</p>

<hr />

<h3 id="conditionally-negate-a-value-without-branching">Conditionally negate a value without branching</h3>

<p>If you need to negate only when a flag is false, then use the following to avoid branching:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">bool</span> fDontNegate;  <span style="color:#007f7f">// Flag indicating we should not negate v.
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">int</span> v;             <span style="color:#007f7f">// Input value to negate if fDontNegate is false.
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">int</span> r;             <span style="color:#007f7f">// result = fDontNegate ? v : -v;
</span><span style="color:#007f7f"></span>
r = (fDontNegate ^ (fDontNegate - <span style="color:#ff0;font-weight:bold">1</span>)) * v;</code></pre></div>
<p>If you need to negate only when a flag is true, then use this:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">bool</span> fNegate;  <span style="color:#007f7f">// Flag indicating if we should negate v.
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">int</span> v;         <span style="color:#007f7f">// Input value to negate if fNegate is true.
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">int</span> r;         <span style="color:#007f7f">// result = fNegate ? -v : v;
</span><span style="color:#007f7f"></span>
r = (v ^ -fNegate) + fNegate;</code></pre></div>
<p>Avraham Plotnitzky suggested I add the first version on June 2, 2009. Motivated to avoid the multiply, I came up with the second version on June 8, 2009. Alfonso De Gregorio pointed out that some parens were missing on November 26, 2009, and received a bug bounty.</p>

<hr />

<h3 id="merge-bits-from-two-values-according-to-a-mask">Merge bits from two values according to a mask</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> a;    <span style="color:#007f7f">// value to merge in non-masked bits
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> b;    <span style="color:#007f7f">// value to merge in masked bits
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> mask; <span style="color:#007f7f">// 1 where bits from b should be selected; 0 where from a.
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> r;    <span style="color:#007f7f">// result of (a &amp; ~mask) | (b &amp; mask) goes here
</span><span style="color:#007f7f"></span>
r = a ^ ((a ^ b) &amp; mask);</code></pre></div>
<p>This shaves one operation from the obvious way of combining two sets of bits according to a bit mask. If the mask is a constant, then there may be no advantage.</p>

<p>Ron Jeffery sent this to me on February 9, 2006.</p>

<hr />

<h3 id="counting-bits-set-naive-way">Counting bits set (naive way)</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> v; <span style="color:#007f7f">// count the number of bits set in v
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> c; <span style="color:#007f7f">// c accumulates the total bits set in v
</span><span style="color:#007f7f"></span>
<span style="color:#fff;font-weight:bold">for</span> (c = <span style="color:#ff0;font-weight:bold">0</span>; v; v &gt;&gt;= <span style="color:#ff0;font-weight:bold">1</span>)
{
  c += v &amp; <span style="color:#ff0;font-weight:bold">1</span>;
}</code></pre></div>
<p>The naive approach requires one iteration per bit, until no more bits are set. So on a 32-bit word with only the high set, it will go through 32 iterations.</p>

<hr />

<h3 id="counting-bits-set-by-lookup-table">Counting bits set by lookup table</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">char</span> BitsSetTable256[<span style="color:#ff0;font-weight:bold">256</span>] =
{
<span style="color:#f00">\</span><span style="color:#0f0;font-weight:bold">#   define B2(n) n,     n+1,     n+1,     n+2
</span><span style="color:#0f0;font-weight:bold"></span><span style="color:#f00">\</span><span style="color:#0f0;font-weight:bold">#   define B4(n) B2(n), B2(n+1), B2(n+1), B2(n+2)
</span><span style="color:#0f0;font-weight:bold"></span><span style="color:#f00">\</span><span style="color:#0f0;font-weight:bold">#   define B6(n) B4(n), B4(n+1), B4(n+1), B4(n+2)
</span><span style="color:#0f0;font-weight:bold"></span>    B6(<span style="color:#ff0;font-weight:bold">0</span>), B6(<span style="color:#ff0;font-weight:bold">1</span>), B6(<span style="color:#ff0;font-weight:bold">1</span>), B6(<span style="color:#ff0;font-weight:bold">2</span>)
};

<span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> v; <span style="color:#007f7f">// count the number of bits set in 32-bit value v
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> c; <span style="color:#007f7f">// c is the total bits set in v
</span><span style="color:#007f7f"></span>
<span style="color:#007f7f">// Option 1:
</span><span style="color:#007f7f"></span>c = BitsSetTable256[v &amp; <span style="color:#ff0;font-weight:bold">0xff</span>] +
    BitsSetTable256[(v &gt;&gt; <span style="color:#ff0;font-weight:bold">8</span>) &amp; <span style="color:#ff0;font-weight:bold">0xff</span>] +
    BitsSetTable256[(v &gt;&gt; <span style="color:#ff0;font-weight:bold">16</span>) &amp; <span style="color:#ff0;font-weight:bold">0xff</span>] +
    BitsSetTable256[v &gt;&gt; <span style="color:#ff0;font-weight:bold">24</span>];

<span style="color:#007f7f">// Option 2:
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">char</span> * p = (<span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">char</span> *) &amp;v;
c = BitsSetTable256[p[<span style="color:#ff0;font-weight:bold">0</span>]] +
    BitsSetTable256[p[<span style="color:#ff0;font-weight:bold">1</span>]] +
    BitsSetTable256[p[<span style="color:#ff0;font-weight:bold">2</span>]] +
    BitsSetTable256[p[<span style="color:#ff0;font-weight:bold">3</span>]];


<span style="color:#007f7f">// To initially generate the table algorithmically:
</span><span style="color:#007f7f"></span>BitsSetTable256[<span style="color:#ff0;font-weight:bold">0</span>] = <span style="color:#ff0;font-weight:bold">0</span>;
<span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">0</span>; i &lt; <span style="color:#ff0;font-weight:bold">256</span>; i++)
{
  BitsSetTable256[i] = (i &amp; <span style="color:#ff0;font-weight:bold">1</span>) + BitsSetTable256[i / <span style="color:#ff0;font-weight:bold">2</span>];
}</code></pre></div>
<p>On July 14, 2009 Hallvard Furuseth suggested the macro compacted table.</p>

<hr />

<h3 id="counting-bits-set-brian-kernighan-s-way">Counting bits set, Brian Kernighan&rsquo;s way</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> v; <span style="color:#007f7f">// count the number of bits set in v
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> c; <span style="color:#007f7f">// c accumulates the total bits set in v
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">for</span> (c = <span style="color:#ff0;font-weight:bold">0</span>; v; c++)
{
  v &amp;= v - <span style="color:#ff0;font-weight:bold">1</span>; <span style="color:#007f7f">// clear the least significant bit set
</span><span style="color:#007f7f"></span>}</code></pre></div>
<p>Brian Kernighan&rsquo;s method goes through as many iterations as there are set bits. So if we have a 32-bit word with only the high bit set, then it will only go once through the loop.</p>

<p>Published in 1988, the C Programming Language 2nd Ed. (by Brian W. Kernighan and Dennis M. Ritchie) mentions this in exercise 2-9. On April 19, 2006 Don Knuth pointed out to me that this method &ldquo;was first published by Peter Wegner in CACM 3 (1960), 322. (Also discovered independently by Derrick Lehmer and published in 1964 in a book edited by Beckenbach.)&rdquo;</p>

<hr />

<h3 id="counting-bits-set-in-14-24-or-32-bit-words-using-64-bit-instructions">Counting bits set in 14, 24, or 32-bit words using 64-bit instructions</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> v; <span style="color:#007f7f">// count the number of bits set in v
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> c; <span style="color:#007f7f">// c accumulates the total bits set in v
</span><span style="color:#007f7f"></span>
<span style="color:#007f7f">// option 1, for at most 14-bit values in v:
</span><span style="color:#007f7f"></span>c = (v * <span style="color:#ff0;font-weight:bold">0x200040008001ULL</span> &amp; <span style="color:#ff0;font-weight:bold">0x111111111111111ULL</span>) % <span style="color:#ff0;font-weight:bold">0xf</span>;

<span style="color:#007f7f">// option 2, for at most 24-bit values in v:
</span><span style="color:#007f7f"></span>c =  ((v &amp; <span style="color:#ff0;font-weight:bold">0xfff</span>) * <span style="color:#ff0;font-weight:bold">0x1001001001001ULL</span> &amp; <span style="color:#ff0;font-weight:bold">0x84210842108421ULL</span>) % <span style="color:#ff0;font-weight:bold">0x1f</span>;
c += (((v &amp; <span style="color:#ff0;font-weight:bold">0xfff000</span>) &gt;&gt; <span style="color:#ff0;font-weight:bold">12</span>) * <span style="color:#ff0;font-weight:bold">0x1001001001001ULL</span> &amp; <span style="color:#ff0;font-weight:bold">0x84210842108421ULL</span>)
     % <span style="color:#ff0;font-weight:bold">0x1f</span>;

<span style="color:#007f7f">// option 3, for at most 32-bit values in v:
</span><span style="color:#007f7f"></span>c =  ((v &amp; <span style="color:#ff0;font-weight:bold">0xfff</span>) * <span style="color:#ff0;font-weight:bold">0x1001001001001ULL</span> &amp; <span style="color:#ff0;font-weight:bold">0x84210842108421ULL</span>) % <span style="color:#ff0;font-weight:bold">0x1f</span>;
c += (((v &amp; <span style="color:#ff0;font-weight:bold">0xfff000</span>) &gt;&gt; <span style="color:#ff0;font-weight:bold">12</span>) * <span style="color:#ff0;font-weight:bold">0x1001001001001ULL</span> &amp; <span style="color:#ff0;font-weight:bold">0x84210842108421ULL</span>) %
     <span style="color:#ff0;font-weight:bold">0x1f</span>;
c += ((v &gt;&gt; <span style="color:#ff0;font-weight:bold">24</span>) * <span style="color:#ff0;font-weight:bold">0x1001001001001ULL</span> &amp; <span style="color:#ff0;font-weight:bold">0x84210842108421ULL</span>) % <span style="color:#ff0;font-weight:bold">0x1f</span>;</code></pre></div>
<p>This method requires a 64-bit CPU with fast modulus division to be efficient. The first option takes only 3 operations; the second option takes 10; and the third option takes 15.</p>

<p>Rich Schroeppel originally created a 9-bit version, similiar to option 1; see the Programming Hacks section of <a href="http://www.inwap.com/pdp10/hbaker/hakmem/hakmem.html">Beeler, M., Gosper, R. W., and Schroeppel, R. HAKMEM. MIT AI Memo 239, Feb. 29, 1972.</a> His method was the inspiration for the variants above, devised by Sean Anderson. Randal E. Bryant offered a couple bug fixes on May 3, 2005. Bruce Dawson tweaked what had been a 12-bit version and made it suitable for 14 bits using the same number of operations on Feburary 1, 2007.</p>

<hr />

<h3 id="counting-bits-set-in-parallel">Counting bits set, in parallel</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> v; <span style="color:#007f7f">// count bits set in this (32-bit value)
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> c; <span style="color:#007f7f">// store the total here
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">int</span> S[] = {<span style="color:#ff0;font-weight:bold">1</span>, <span style="color:#ff0;font-weight:bold">2</span>, <span style="color:#ff0;font-weight:bold">4</span>, <span style="color:#ff0;font-weight:bold">8</span>, <span style="color:#ff0;font-weight:bold">16</span>}; <span style="color:#007f7f">// Magic Binary Numbers
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">int</span> B[] = {<span style="color:#ff0;font-weight:bold">0x55555555</span>, <span style="color:#ff0;font-weight:bold">0x33333333</span>, <span style="color:#ff0;font-weight:bold">0x0F0F0F0F</span>, <span style="color:#ff0;font-weight:bold">0x00FF00FF</span>, <span style="color:#ff0;font-weight:bold">0x0000FFFF</span>};

c = v - ((v &gt;&gt; <span style="color:#ff0;font-weight:bold">1</span>) &amp; B[<span style="color:#ff0;font-weight:bold">0</span>]);
c = ((c &gt;&gt; S[<span style="color:#ff0;font-weight:bold">1</span>]) &amp; B[<span style="color:#ff0;font-weight:bold">1</span>]) + (c &amp; B[<span style="color:#ff0;font-weight:bold">1</span>]);
c = ((c &gt;&gt; S[<span style="color:#ff0;font-weight:bold">2</span>]) + c) &amp; B[<span style="color:#ff0;font-weight:bold">2</span>];
c = ((c &gt;&gt; S[<span style="color:#ff0;font-weight:bold">3</span>]) + c) &amp; B[<span style="color:#ff0;font-weight:bold">3</span>];
c = ((c &gt;&gt; S[<span style="color:#ff0;font-weight:bold">4</span>]) + c) &amp; B[<span style="color:#ff0;font-weight:bold">4</span>];

The B array, expressed as binary, is:

B[<span style="color:#ff0;font-weight:bold">0</span>] = <span style="color:#ff0;font-weight:bold">0x55555555</span> = <span style="color:#ff0;font-weight:bold">01010101</span> <span style="color:#ff0;font-weight:bold">01010101</span> <span style="color:#ff0;font-weight:bold">01010101</span> <span style="color:#ff0;font-weight:bold">01010101</span>
B[<span style="color:#ff0;font-weight:bold">1</span>] = <span style="color:#ff0;font-weight:bold">0x33333333</span> = <span style="color:#ff0;font-weight:bold">00110011</span> <span style="color:#ff0;font-weight:bold">00110011</span> <span style="color:#ff0;font-weight:bold">00110011</span> <span style="color:#ff0;font-weight:bold">00110011</span>
B[<span style="color:#ff0;font-weight:bold">2</span>] = <span style="color:#ff0;font-weight:bold">0x0F0F0F0F</span> = <span style="color:#ff0;font-weight:bold">00001111</span> <span style="color:#ff0;font-weight:bold">00001111</span> <span style="color:#ff0;font-weight:bold">00001111</span> <span style="color:#ff0;font-weight:bold">00001111</span>
B[<span style="color:#ff0;font-weight:bold">3</span>] = <span style="color:#ff0;font-weight:bold">0x00FF00FF</span> = <span style="color:#ff0;font-weight:bold">00000000</span> <span style="color:#ff0;font-weight:bold">11111111</span> <span style="color:#ff0;font-weight:bold">00000000</span> <span style="color:#ff0;font-weight:bold">11111111</span>
B[<span style="color:#ff0;font-weight:bold">4</span>] = <span style="color:#ff0;font-weight:bold">0x0000FFFF</span> = <span style="color:#ff0;font-weight:bold">00000000</span> <span style="color:#ff0;font-weight:bold">00000000</span> <span style="color:#ff0;font-weight:bold">11111111</span> <span style="color:#ff0;font-weight:bold">11111111</span></code></pre></div>
<p>We can adjust the method for larger integer sizes by continuing with the patterns for the <em>Binary Magic Numbers,</em> B and S. If there are k bits, then we need the arrays S and B to be ceil(lg(k)) elements long, and we must compute the same number of expressions for c as S or B are long. For a 32-bit v, 16 operations are used.</p>

<p>The best method for counting bits in a 32-bit integer v is the following:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">v = v - ((v &gt;&gt; <span style="color:#ff0;font-weight:bold">1</span>) &amp; <span style="color:#ff0;font-weight:bold">0x55555555</span>);                    <span style="color:#007f7f">// reuse input as temporary
</span><span style="color:#007f7f"></span>v = (v &amp; <span style="color:#ff0;font-weight:bold">0x33333333</span>) + ((v &gt;&gt; <span style="color:#ff0;font-weight:bold">2</span>) &amp; <span style="color:#ff0;font-weight:bold">0x33333333</span>);     <span style="color:#007f7f">// temp
</span><span style="color:#007f7f"></span>c = ((v + (v &gt;&gt; <span style="color:#ff0;font-weight:bold">4</span>) &amp; <span style="color:#ff0;font-weight:bold">0xF0F0F0F</span>) * <span style="color:#ff0;font-weight:bold">0x1010101</span>) &gt;&gt; <span style="color:#ff0;font-weight:bold">24</span>; // count</code></pre></div>
<p>The best bit counting method takes only 12 operations, which is the same as the lookup-table method, but avoids the memory and potential cache misses of a table. It is a hybrid between the purely parallel method above and the earlier methods using multiplies (in the section on counting bits with 64-bit instructions), though it doesn&rsquo;t use 64-bit instructions. The counts of bits set in the bytes is done in parallel, and the sum total of the bits set in the bytes is computed by multiplying by 0x1010101 and shifting right 24 bits.</p>

<p>A generalization of the best bit counting method to integers of bit-widths upto 128 (parameterized by type T) is this:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">v = v - ((v &gt;&gt; <span style="color:#ff0;font-weight:bold">1</span>) &amp; (T)~(T)<span style="color:#ff0;font-weight:bold">0</span>/<span style="color:#ff0;font-weight:bold">3</span>);                           <span style="color:#007f7f">// temp
</span><span style="color:#007f7f"></span>v = (v &amp; (T)~(T)<span style="color:#ff0;font-weight:bold">0</span>/<span style="color:#ff0;font-weight:bold">15</span>*<span style="color:#ff0;font-weight:bold">3</span>) + ((v &gt;&gt; <span style="color:#ff0;font-weight:bold">2</span>) &amp; (T)~(T)<span style="color:#ff0;font-weight:bold">0</span>/<span style="color:#ff0;font-weight:bold">15</span>*<span style="color:#ff0;font-weight:bold">3</span>);      <span style="color:#007f7f">// temp
</span><span style="color:#007f7f"></span>v = (v + (v &gt;&gt; <span style="color:#ff0;font-weight:bold">4</span>)) &amp; (T)~(T)<span style="color:#ff0;font-weight:bold">0</span>/<span style="color:#ff0;font-weight:bold">255</span>*<span style="color:#ff0;font-weight:bold">15</span>;                      <span style="color:#007f7f">// temp
</span><span style="color:#007f7f"></span>c = (T)(v * ((T)~(T)<span style="color:#ff0;font-weight:bold">0</span>/<span style="color:#ff0;font-weight:bold">255</span>)) &gt;&gt; (<span style="color:#fff;font-weight:bold">sizeof</span>(T) - <span style="color:#ff0;font-weight:bold">1</span>) * CHAR_BIT; // count</code></pre></div>
<p>See <a href="http://groups.google.com/groups?q=reverse+bits&amp;num=100&amp;hl=en&amp;group=comp.graphics.algorithms&amp;imgsafe=off&amp;safe=off&amp;rnum=2&amp;ic=1&amp;selm=4fulhm%248dn%40atlas.uniserve.com">Ian Ashdown&rsquo;s nice newsgroup post</a> for more information on counting the number of bits set (also known as <em>sideways addition</em>). The best bit counting method was brought to my attention on October 5, 2005 by <a href="http://onezero.org">Andrew Shapira</a>; he found it in pages 187-188 of <a href="http://www.amd.com/us-en/assets/content_type/white_papers_and_tech_docs/25112.PDF">Software Optimization Guide for AMD Athlon™ 64 and Opteron™ Processors</a>. Charlie Gordon suggested a way to shave off one operation from the purely parallel version on December 14, 2005, and Don Clugston trimmed three more from it on December 30, 2005. I made a typo with Don&rsquo;s suggestion that Eric Cole spotted on January 8, 2006. Eric later suggested the arbitrary bit-width generalization to the best method on November 17, 2006. On April 5, 2007, Al Williams observed that I had a line of dead code at the top of the first method.</p>

<hr />

<h3 id="count-bits-set-rank-from-the-most-significant-bit-upto-a-given-position">Count bits set (rank) from the most-significant bit upto a given position</h3>

<p>The following finds the the rank of a bit, meaning it returns the sum of bits that are set to 1 from the most-signficant bit downto the bit at the given position.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">  uint64_t v;       <span style="color:#007f7f">// Compute the rank (bits set) in v from the MSB to pos.
</span><span style="color:#007f7f"></span>  <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> pos; <span style="color:#007f7f">// Bit position to count bits upto.
</span><span style="color:#007f7f"></span>  uint64_t r;       <span style="color:#007f7f">// Resulting rank of bit at pos goes here.
</span><span style="color:#007f7f"></span>
  <span style="color:#007f7f">// Shift out bits after given position.
</span><span style="color:#007f7f"></span>  r = v &gt;&gt; (<span style="color:#fff;font-weight:bold">sizeof</span>(v) * CHAR_BIT - pos);
  <span style="color:#007f7f">// Count set bits in parallel.
</span><span style="color:#007f7f"></span>  <span style="color:#007f7f">// r = (r &amp; 0x5555...) + ((r &gt;&gt; 1) &amp; 0x5555...);
</span><span style="color:#007f7f"></span>  r = r - ((r &gt;&gt; <span style="color:#ff0;font-weight:bold">1</span>) &amp; ~<span style="color:#ff0;font-weight:bold">0UL</span>/<span style="color:#ff0;font-weight:bold">3</span>);
  <span style="color:#007f7f">// r = (r &amp; 0x3333...) + ((r &gt;&gt; 2) &amp; 0x3333...);
</span><span style="color:#007f7f"></span>  r = (r &amp; ~<span style="color:#ff0;font-weight:bold">0UL</span>/<span style="color:#ff0;font-weight:bold">5</span>) + ((r &gt;&gt; <span style="color:#ff0;font-weight:bold">2</span>) &amp; ~<span style="color:#ff0;font-weight:bold">0UL</span>/<span style="color:#ff0;font-weight:bold">5</span>);
  <span style="color:#007f7f">// r = (r &amp; 0x0f0f...) + ((r &gt;&gt; 4) &amp; 0x0f0f...);
</span><span style="color:#007f7f"></span>  r = (r + (r &gt;&gt; <span style="color:#ff0;font-weight:bold">4</span>)) &amp; ~<span style="color:#ff0;font-weight:bold">0UL</span>/<span style="color:#ff0;font-weight:bold">17</span>;
  <span style="color:#007f7f">// r = r % 255;
</span><span style="color:#007f7f"></span>  r = (r * (~<span style="color:#ff0;font-weight:bold">0UL</span>/<span style="color:#ff0;font-weight:bold">255</span>)) &gt;&gt; ((<span style="color:#fff;font-weight:bold">sizeof</span>(v) - <span style="color:#ff0;font-weight:bold">1</span>) * CHAR_BIT);</code></pre></div>
<p>Juha Järvi sent this to me on November 21, 2009 as an inverse operation to the computing the bit position with the given rank, which follows.</p>

<hr />

<h3 id="select-the-bit-position-from-the-most-significant-bit-with-the-given-count-rank">Select the bit position (from the most-significant bit) with the given count (rank)</h3>

<p>The following 64-bit code selects the position of the rth 1 bit when counting from the left. In other words if we start at the most significant bit and proceed to the right, counting the number of bits set to 1 until we reach the desired rank, r, then the position where we stop is returned. If the rank requested exceeds the count of bits set, then 64 is returned. The code may be modified for 32-bit or counting from the right.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">  uint64_t v;          <span style="color:#007f7f">// Input value to find position with rank r.
</span><span style="color:#007f7f"></span>  <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> r;      <span style="color:#007f7f">// Input: bit&#39;s desired rank [1-64].
</span><span style="color:#007f7f"></span>  <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> s;      <span style="color:#007f7f">// Output: Resulting position of bit with rank r [1-64]
</span><span style="color:#007f7f"></span>  uint64_t a, b, c, d; <span style="color:#007f7f">// Intermediate temporaries for bit count.
</span><span style="color:#007f7f"></span>  <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> t;      <span style="color:#007f7f">// Bit count temporary.
</span><span style="color:#007f7f"></span>
  <span style="color:#007f7f">// Do a normal parallel bit count for a 64-bit integer,
</span><span style="color:#007f7f"></span>  <span style="color:#007f7f">// but store all intermediate steps.
</span><span style="color:#007f7f"></span>  <span style="color:#007f7f">// a = (v &amp; 0x5555...) + ((v &gt;&gt; 1) &amp; 0x5555...);
</span><span style="color:#007f7f"></span>  a =  v - ((v &gt;&gt; <span style="color:#ff0;font-weight:bold">1</span>) &amp; ~<span style="color:#ff0;font-weight:bold">0UL</span>/<span style="color:#ff0;font-weight:bold">3</span>);
  <span style="color:#007f7f">// b = (a &amp; 0x3333...) + ((a &gt;&gt; 2) &amp; 0x3333...);
</span><span style="color:#007f7f"></span>  b = (a &amp; ~<span style="color:#ff0;font-weight:bold">0UL</span>/<span style="color:#ff0;font-weight:bold">5</span>) + ((a &gt;&gt; <span style="color:#ff0;font-weight:bold">2</span>) &amp; ~<span style="color:#ff0;font-weight:bold">0UL</span>/<span style="color:#ff0;font-weight:bold">5</span>);
  <span style="color:#007f7f">// c = (b &amp; 0x0f0f...) + ((b &gt;&gt; 4) &amp; 0x0f0f...);
</span><span style="color:#007f7f"></span>  c = (b + (b &gt;&gt; <span style="color:#ff0;font-weight:bold">4</span>)) &amp; ~<span style="color:#ff0;font-weight:bold">0UL</span>/<span style="color:#ff0;font-weight:bold">0x11</span>;
  <span style="color:#007f7f">// d = (c &amp; 0x00ff...) + ((c &gt;&gt; 8) &amp; 0x00ff...);
</span><span style="color:#007f7f"></span>  d = (c + (c &gt;&gt; <span style="color:#ff0;font-weight:bold">8</span>)) &amp; ~<span style="color:#ff0;font-weight:bold">0UL</span>/<span style="color:#ff0;font-weight:bold">0x101</span>;
  t = (d &gt;&gt; <span style="color:#ff0;font-weight:bold">32</span>) + (d &gt;&gt; <span style="color:#ff0;font-weight:bold">48</span>);
  <span style="color:#007f7f">// Now do branchless select!
</span><span style="color:#007f7f"></span>  s  = <span style="color:#ff0;font-weight:bold">64</span>;
  <span style="color:#007f7f">// if (r &gt; t) {s -= 32; r -= t;}
</span><span style="color:#007f7f"></span>  s -= ((t - r) &amp; <span style="color:#ff0;font-weight:bold">256</span>) &gt;&gt; <span style="color:#ff0;font-weight:bold">3</span>; r -= (t &amp; ((t - r) &gt;&gt; <span style="color:#ff0;font-weight:bold">8</span>));
  t  = (d &gt;&gt; (s - <span style="color:#ff0;font-weight:bold">16</span>)) &amp; <span style="color:#ff0;font-weight:bold">0xff</span>;
  <span style="color:#007f7f">// if (r &gt; t) {s -= 16; r -= t;}
</span><span style="color:#007f7f"></span>  s -= ((t - r) &amp; <span style="color:#ff0;font-weight:bold">256</span>) &gt;&gt; <span style="color:#ff0;font-weight:bold">4</span>; r -= (t &amp; ((t - r) &gt;&gt; <span style="color:#ff0;font-weight:bold">8</span>));
  t  = (c &gt;&gt; (s - <span style="color:#ff0;font-weight:bold">8</span>)) &amp; <span style="color:#ff0;font-weight:bold">0xf</span>;
  <span style="color:#007f7f">// if (r &gt; t) {s -= 8; r -= t;}
</span><span style="color:#007f7f"></span>  s -= ((t - r) &amp; <span style="color:#ff0;font-weight:bold">256</span>) &gt;&gt; <span style="color:#ff0;font-weight:bold">5</span>; r -= (t &amp; ((t - r) &gt;&gt; <span style="color:#ff0;font-weight:bold">8</span>));
  t  = (b &gt;&gt; (s - <span style="color:#ff0;font-weight:bold">4</span>)) &amp; <span style="color:#ff0;font-weight:bold">0x7</span>;
  <span style="color:#007f7f">// if (r &gt; t) {s -= 4; r -= t;}
</span><span style="color:#007f7f"></span>  s -= ((t - r) &amp; <span style="color:#ff0;font-weight:bold">256</span>) &gt;&gt; <span style="color:#ff0;font-weight:bold">6</span>; r -= (t &amp; ((t - r) &gt;&gt; <span style="color:#ff0;font-weight:bold">8</span>));
  t  = (a &gt;&gt; (s - <span style="color:#ff0;font-weight:bold">2</span>)) &amp; <span style="color:#ff0;font-weight:bold">0x3</span>;
  <span style="color:#007f7f">// if (r &gt; t) {s -= 2; r -= t;}
</span><span style="color:#007f7f"></span>  s -= ((t - r) &amp; <span style="color:#ff0;font-weight:bold">256</span>) &gt;&gt; <span style="color:#ff0;font-weight:bold">7</span>; r -= (t &amp; ((t - r) &gt;&gt; <span style="color:#ff0;font-weight:bold">8</span>));
  t  = (v &gt;&gt; (s - <span style="color:#ff0;font-weight:bold">1</span>)) &amp; <span style="color:#ff0;font-weight:bold">0x1</span>;
  <span style="color:#007f7f">// if (r &gt; t) s--;
</span><span style="color:#007f7f"></span>  s -= ((t - r) &amp; <span style="color:#ff0;font-weight:bold">256</span>) &gt;&gt; <span style="color:#ff0;font-weight:bold">8</span>;
  s = <span style="color:#ff0;font-weight:bold">65</span> - s;</code></pre></div>
<p>If branching is fast on your target CPU, consider uncommenting the if-statements and commenting the lines that follow them.</p>

<p>Juha Järvi sent this to me on November 21, 2009.</p>

<hr />

<h3 id="computing-parity-the-naive-way">Computing parity the naive way</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> v;       <span style="color:#007f7f">// word value to compute the parity of
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">bool</span> parity = <span style="color:#fff;font-weight:bold">false</span>;  <span style="color:#007f7f">// parity will be the parity of v
</span><span style="color:#007f7f"></span>
<span style="color:#fff;font-weight:bold">while</span> (v)
{
  parity = !parity;
  v = v &amp; (v - <span style="color:#ff0;font-weight:bold">1</span>);
}</code></pre></div>
<p>The above code uses an approach like Brian Kernigan&rsquo;s bit counting, above. The time it takes is proportional to the number of bits set.</p>

<hr />

<h3 id="compute-parity-by-lookup-table">Compute parity by lookup table</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">bool</span> ParityTable256[<span style="color:#ff0;font-weight:bold">256</span>] =
{
<span style="color:#f00">\</span><span style="color:#0f0;font-weight:bold">#   define P2(n) n, n^1, n^1, n
</span><span style="color:#0f0;font-weight:bold"></span><span style="color:#f00">\</span><span style="color:#0f0;font-weight:bold">#   define P4(n) P2(n), P2(n^1), P2(n^1), P2(n)
</span><span style="color:#0f0;font-weight:bold"></span><span style="color:#f00">\</span><span style="color:#0f0;font-weight:bold">#   define P6(n) P4(n), P4(n^1), P4(n^1), P4(n)
</span><span style="color:#0f0;font-weight:bold"></span>    P6(<span style="color:#ff0;font-weight:bold">0</span>), P6(<span style="color:#ff0;font-weight:bold">1</span>), P6(<span style="color:#ff0;font-weight:bold">1</span>), P6(<span style="color:#ff0;font-weight:bold">0</span>)
};

<span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">char</span> b;  <span style="color:#007f7f">// byte value to compute the parity of
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">bool</span> parity = ParityTable256[b];

<span style="color:#007f7f">// OR, for 32-bit words:
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> v;
v ^= v &gt;&gt; <span style="color:#ff0;font-weight:bold">16</span>;
v ^= v &gt;&gt; <span style="color:#ff0;font-weight:bold">8</span>;
<span style="color:#fff;font-weight:bold">bool</span> parity = ParityTable256[v &amp; <span style="color:#ff0;font-weight:bold">0xff</span>];

<span style="color:#007f7f">// Variation:
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">char</span> * p = (<span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">char</span> *) &amp;v;
parity = ParityTable256[p[<span style="color:#ff0;font-weight:bold">0</span>] ^ p[<span style="color:#ff0;font-weight:bold">1</span>] ^ p[<span style="color:#ff0;font-weight:bold">2</span>] ^ p[<span style="color:#ff0;font-weight:bold">3</span>]];</code></pre></div>
<p>Randal E. Bryant encouraged the addition of the (admittedly) obvious last variation with variable p on May 3, 2005. Bruce Rawles found a typo in an instance of the table variable&rsquo;s name on September 27, 2005, and he received a $10 bug bounty. On October 9, 2006, Fabrice Bellard suggested the 32-bit variations above, which require only one table lookup; the previous version had four lookups (one per byte) and were slower. On July 14, 2009 Hallvard Furuseth suggested the macro compacted table.</p>

<hr />

<h3 id="compute-parity-of-a-byte-using-64-bit-multiply-and-modulus-division">Compute parity of a byte using 64-bit multiply and modulus division</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">char</span> b;  <span style="color:#007f7f">// byte value to compute the parity of
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">bool</span> parity =
  (((b * <span style="color:#ff0;font-weight:bold">0x0101010101010101ULL</span>) &amp; <span style="color:#ff0;font-weight:bold">0x8040201008040201ULL</span>) % <span style="color:#ff0;font-weight:bold">0x1FF</span>) &amp; <span style="color:#ff0;font-weight:bold">1</span>;</code></pre></div>
<p>The method above takes around 4 operations, but only works on bytes.</p>

<hr />

<h3 id="compute-parity-of-word-with-a-multiply">Compute parity of word with a multiply</h3>

<p>The following method computes the parity of the 32-bit value in only 8 operations using a multiply.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">    <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> v; <span style="color:#007f7f">// 32-bit word
</span><span style="color:#007f7f"></span>    v ^= v &gt;&gt; <span style="color:#ff0;font-weight:bold">1</span>;
    v ^= v &gt;&gt; <span style="color:#ff0;font-weight:bold">2</span>;
    v = (v &amp; <span style="color:#ff0;font-weight:bold">0x11111111U</span>) * <span style="color:#ff0;font-weight:bold">0x11111111U</span>;
    <span style="color:#fff;font-weight:bold">return</span> (v &gt;&gt; <span style="color:#ff0;font-weight:bold">28</span>) &amp; <span style="color:#ff0;font-weight:bold">1</span>;

Also <span style="color:#fff;font-weight:bold">for</span> <span style="color:#ff0;font-weight:bold">64</span>-bits, <span style="color:#ff0;font-weight:bold">8</span> operations are still enough.

    <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">long</span> <span style="color:#fff;font-weight:bold">long</span> v; <span style="color:#007f7f">// 64-bit word
</span><span style="color:#007f7f"></span>    v ^= v &gt;&gt; <span style="color:#ff0;font-weight:bold">1</span>;
    v ^= v &gt;&gt; <span style="color:#ff0;font-weight:bold">2</span>;
    v = (v &amp; <span style="color:#ff0;font-weight:bold">0x1111111111111111UL</span>) * <span style="color:#ff0;font-weight:bold">0x1111111111111111UL</span>;
    <span style="color:#fff;font-weight:bold">return</span> (v &gt;&gt; <span style="color:#ff0;font-weight:bold">60</span>) &amp; <span style="color:#ff0;font-weight:bold">1</span>;</code></pre></div>
<p>Andrew Shapira came up with this and sent it to me on Sept. 2, 2007.</p>

<hr />

<h3 id="compute-parity-in-parallel">Compute parity in parallel</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> v;  <span style="color:#007f7f">// word value to compute the parity of
</span><span style="color:#007f7f"></span>v ^= v &gt;&gt; <span style="color:#ff0;font-weight:bold">16</span>;
v ^= v &gt;&gt; <span style="color:#ff0;font-weight:bold">8</span>;
v ^= v &gt;&gt; <span style="color:#ff0;font-weight:bold">4</span>;
v &amp;= <span style="color:#ff0;font-weight:bold">0xf</span>;
<span style="color:#fff;font-weight:bold">return</span> (<span style="color:#ff0;font-weight:bold">0x6996</span> &gt;&gt; v) &amp; <span style="color:#ff0;font-weight:bold">1</span>;</code></pre></div>
<p>The method above takes around 9 operations, and works for 32-bit words. It may be optimized to work just on bytes in 5 operations by removing the two lines immediately following &ldquo;unsigned int v;&rdquo;. The method first shifts and XORs the eight nibbles of the 32-bit value together, leaving the result in the lowest nibble of v. Next, the binary number 0110 1001 1001 0110 (0x6996 in hex) is shifted to the right by the value represented in the lowest nibble of v. This number is like a miniature 16-bit parity-table indexed by the low four bits in v. The result has the parity of v in bit 1, which is masked and returned.</p>

<p>Thanks to Mathew Hendry for pointing out the shift-lookup idea at the end on Dec. 15, 2002. That optimization shaves two operations off using only shifting and XORing to find the parity.</p>

<hr />

<h3 id="swapping-values-with-subtraction-and-addition">Swapping values with subtraction and addition</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#0f0;font-weight:bold">#define SWAP(a, b) ((&amp;(a) == &amp;(b)) || \
</span><span style="color:#0f0;font-weight:bold"></span>                    (((a) -= (b)), ((b) += (a)), ((a) = (b) - (a))))</code></pre></div>
<p>This swaps the values of a and b <em>without using a temporary variable.</em> The initial check for a and b being the same location in memory may be omitted when you know this can&rsquo;t happen. (The compiler may omit it anyway as an optimization.) If you enable overflows exceptions, then pass unsigned values so an exception isn&rsquo;t thrown. The XOR method that follows may be slightly faster on some machines. Don&rsquo;t use this with floating-point numbers (unless you operate on their raw integer representations).</p>

<p>Sanjeev Sivasankaran suggested I add this on June 12, 2007. Vincent Lefèvre pointed out the potential for overflow exceptions on July 9, 2008</p>

<hr />

<h3 id="swapping-values-with-xor">Swapping values with XOR</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#0f0;font-weight:bold">#define SWAP(a, b) (((a) ^= (b)), ((b) ^= (a)), ((a) ^= (b)))</span></code></pre></div>
<p>This is an old trick to exchange the values of the variables a and b <em>without using extra space for a temporary variable</em>.</p>

<p>On January 20, 2005, Iain A. Fleming pointed out that the macro above doesn&rsquo;t work when you swap with the same memory location, such as <code>SWAP(a[i], a[j]) with i == j</code>. So if that may occur, consider defining the macro as <code>(((a) == (b)) || (((a) ^= (b)), ((b) ^= (a)), ((a) ^= (b))))</code>. On July 14, 2009, Hallvard Furuseth suggested that on some machines, <code>(((a) ^ (b)) &amp;&amp; ((b) ^= (a) ^= (b), (a) ^= (b)))</code> might be faster, since the <code>(a) ^ (b)</code> expression is reused.</p>

<hr />

<h3 id="swapping-individual-bits-with-xor">Swapping individual bits with XOR</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> i, j; <span style="color:#007f7f">// positions of bit sequences to swap
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> n;    <span style="color:#007f7f">// number of consecutive bits in each sequence
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> b;    <span style="color:#007f7f">// bits to swap reside in b
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> r;    <span style="color:#007f7f">// bit-swapped result goes here
</span><span style="color:#007f7f"></span>
<span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> x = ((b &gt;&gt; i) ^ (b &gt;&gt; j)) &amp; ((<span style="color:#ff0;font-weight:bold">1U</span> &lt;&lt; n) - <span style="color:#ff0;font-weight:bold">1</span>); <span style="color:#007f7f">// XOR temporary
</span><span style="color:#007f7f"></span>r = b ^ ((x &lt;&lt; i) | (x &lt;&lt; j));</code></pre></div>
<p>As an example of swapping ranges of bits suppose we have have b = <strong>001</strong>0<strong>111</strong>1 (expressed in binary) and we want to swap the n = 3 consecutive bits starting at i = 1 (the second bit from the right) with the 3 consecutive bits starting at j = 5; the result would be r = <strong>111</strong>0<strong>001</strong>1 (binary).</p>

<p>This method of swapping is similar to the general purpose XOR swap trick, but intended for operating on individual bits.  The variable x stores the result of XORing the pairs of bit values we want to swap, and then the bits are set to the result of themselves XORed with x.  Of course, the result is undefined if the sequences overlap.</p>

<p>On July 14, 2009 Hallvard Furuseth suggested that I change the 1 &lt;&lt; n to 1U &lt;&lt; n because the value was being assigned to an unsigned and to avoid shifting into a sign bit.</p>

<hr />

<h3 id="reverse-bits-the-obvious-way">Reverse bits the obvious way</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> v;     <span style="color:#007f7f">// input bits to be reversed
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> r = v; <span style="color:#007f7f">// r will be reversed bits of v; first get LSB of v
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">int</span> s = <span style="color:#fff;font-weight:bold">sizeof</span>(v) * CHAR_BIT - <span style="color:#ff0;font-weight:bold">1</span>; <span style="color:#007f7f">// extra shift needed at end
</span><span style="color:#007f7f"></span>
<span style="color:#fff;font-weight:bold">for</span> (v &gt;&gt;= <span style="color:#ff0;font-weight:bold">1</span>; v; v &gt;&gt;= <span style="color:#ff0;font-weight:bold">1</span>)
{
  r &lt;&lt;= <span style="color:#ff0;font-weight:bold">1</span>;
  r |= v &amp; <span style="color:#ff0;font-weight:bold">1</span>;
  s--;
}
r &lt;&lt;= s; // shift when v<span style="color:#f00">&#39;</span>s highest bits are zero</code></pre></div>
<p>On October 15, 2004, Michael Hoisie pointed out a bug in the original version. Randal E. Bryant suggested removing an extra operation on May 3, 2005. Behdad Esfabod suggested a slight change that eliminated one iteration of the loop on May 18, 2005. Then, on February 6, 2007, Liyong Zhou suggested a better version that loops while v is not 0, so rather than iterating over all bits it stops early.</p>

<hr />

<h3 id="reverse-bits-in-word-by-lookup-table">Reverse bits in word by lookup table</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">char</span> BitReverseTable256[<span style="color:#ff0;font-weight:bold">256</span>] =
{
<span style="color:#0f0;font-weight:bold">#   define R2(n)     n,     n + 2*64,     n + 1*64,     n + 3*64
</span><span style="color:#0f0;font-weight:bold">#   define R4(n) R2(n), R2(n + 2*16), R2(n + 1*16), R2(n + 3*16)
</span><span style="color:#0f0;font-weight:bold">#   define R6(n) R4(n), R4(n + 2*4 ), R4(n + 1*4 ), R4(n + 3*4 )
</span><span style="color:#0f0;font-weight:bold"></span>    R6(<span style="color:#ff0;font-weight:bold">0</span>), R6(<span style="color:#ff0;font-weight:bold">2</span>), R6(<span style="color:#ff0;font-weight:bold">1</span>), R6(<span style="color:#ff0;font-weight:bold">3</span>)
};

<span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> v; <span style="color:#007f7f">// reverse 32-bit value, 8 bits at time
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> c; <span style="color:#007f7f">// c will get v reversed
</span><span style="color:#007f7f"></span>
<span style="color:#007f7f">// Option 1:
</span><span style="color:#007f7f"></span>c = (BitReverseTable256[v &amp; <span style="color:#ff0;font-weight:bold">0xff</span>] &lt;&lt; <span style="color:#ff0;font-weight:bold">24</span>) |
    (BitReverseTable256[(v &gt;&gt; <span style="color:#ff0;font-weight:bold">8</span>) &amp; <span style="color:#ff0;font-weight:bold">0xff</span>] &lt;&lt; <span style="color:#ff0;font-weight:bold">16</span>) |
    (BitReverseTable256[(v &gt;&gt; <span style="color:#ff0;font-weight:bold">16</span>) &amp; <span style="color:#ff0;font-weight:bold">0xff</span>] &lt;&lt; <span style="color:#ff0;font-weight:bold">8</span>) |
    (BitReverseTable256[(v &gt;&gt; <span style="color:#ff0;font-weight:bold">24</span>) &amp; <span style="color:#ff0;font-weight:bold">0xff</span>]);

<span style="color:#007f7f">// Option 2:
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">char</span> * p = (<span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">char</span> *) &amp;v;  
<span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">char</span> * q = (<span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">char</span> *) &amp;c;  
q[<span style="color:#ff0;font-weight:bold">3</span>] = BitReverseTable256[p[<span style="color:#ff0;font-weight:bold">0</span>]];  
q[<span style="color:#ff0;font-weight:bold">2</span>] = BitReverseTable256[p[<span style="color:#ff0;font-weight:bold">1</span>]];  
q[<span style="color:#ff0;font-weight:bold">1</span>] = BitReverseTable256[p[<span style="color:#ff0;font-weight:bold">2</span>]];  
q[<span style="color:#ff0;font-weight:bold">0</span>] = BitReverseTable256[p[<span style="color:#ff0;font-weight:bold">3</span>]];  </code></pre></div>
<p>The first method takes about 17 operations, and the second takes about 12, assuming your CPU can load and store bytes easily.</p>

<p>On July 14, 2009 Hallvard Furuseth suggested the macro compacted table.</p>

<hr />

<h3 id="reverse-the-bits-in-a-byte-with-3-operations-64-bit-multiply-and-modulus-division">Reverse the bits in a byte with 3 operations (64-bit multiply and modulus division):</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">char</span> b; <span style="color:#007f7f">// reverse this (8-bit) byte
</span><span style="color:#007f7f"></span>  
b = (b * <span style="color:#ff0;font-weight:bold">0x0202020202ULL</span> &amp; <span style="color:#ff0;font-weight:bold">0x010884422010ULL</span>) % <span style="color:#ff0;font-weight:bold">1023</span>;</code></pre></div>
<p>The multiply operation creates five separate copies of the 8-bit byte pattern to fan-out into a 64-bit value. The AND operation selects the bits that are in the correct (reversed) positions, relative to each 10-bit groups of bits. The multiply and the AND operations copy the bits from the original byte so they each appear in only one of the 10-bit sets. The reversed positions of the bits from the original byte coincide with their relative positions within any 10-bit set. The last step, which involves modulus division by 2^10 - 1, has the effect of merging together each set of 10 bits (from positions 0-9, 10-19, 20-29, &hellip;) in the 64-bit value. They do not overlap, so the addition steps underlying the modulus division behave like or operations.</p>

<p>This method was attributed to Rich Schroeppel in the Programming Hacks section of <a href="http://www.inwap.com/pdp10/hbaker/hakmem/hakmem.html">Beeler, M., Gosper, R. W., and Schroeppel, R. HAKMEM. MIT AI Memo 239, Feb. 29, 1972.</a></p>

<hr />

<h3 id="reverse-the-bits-in-a-byte-with-4-operations-64-bit-multiply-no-division">Reverse the bits in a byte with 4 operations (64-bit multiply, no division):</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">char</span> b; <span style="color:#007f7f">// reverse this byte
</span><span style="color:#007f7f"></span>
b = ((b * <span style="color:#ff0;font-weight:bold">0x80200802ULL</span>) &amp; <span style="color:#ff0;font-weight:bold">0x0884422110ULL</span>) * <span style="color:#ff0;font-weight:bold">0x0101010101ULL</span> &gt;&gt; <span style="color:#ff0;font-weight:bold">32</span>;</code></pre></div>
<p>The following shows the flow of the bit values with the boolean variables <code>a, b, c, d, e, f, g,</code> and <code>h</code>, which comprise an 8-bit byte. Notice how the first multiply fans out the bit pattern to multiple copies, while the last multiply combines them in the fifth byte from the right.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">                                                                                         abcd efgh (-&gt; hgfe dcba)
*                                                      <span style="color:#ff0;font-weight:bold">1000</span> <span style="color:#ff0;font-weight:bold">0000</span>  <span style="color:#ff0;font-weight:bold">0010</span> <span style="color:#ff0;font-weight:bold">0000</span>  <span style="color:#ff0;font-weight:bold">0000</span> <span style="color:#ff0;font-weight:bold">1000</span>  <span style="color:#ff0;font-weight:bold">0000</span> <span style="color:#ff0;font-weight:bold">0010</span> (<span style="color:#ff0;font-weight:bold">0x80200802</span>)
-------------------------------------------------------------------------------------------------
                                            <span style="color:#ff0;font-weight:bold">0</span>abc defg  h00a bcde  fgh0 <span style="color:#ff0;font-weight:bold">0</span>abc  defg h00a  bcde fgh0
&amp;                                           <span style="color:#ff0;font-weight:bold">0000</span> <span style="color:#ff0;font-weight:bold">1000</span>  <span style="color:#ff0;font-weight:bold">1000</span> <span style="color:#ff0;font-weight:bold">0100</span>  <span style="color:#ff0;font-weight:bold">0100</span> <span style="color:#ff0;font-weight:bold">0010</span>  <span style="color:#ff0;font-weight:bold">0010</span> <span style="color:#ff0;font-weight:bold">0001</span>  <span style="color:#ff0;font-weight:bold">0001</span> <span style="color:#ff0;font-weight:bold">0000</span> (<span style="color:#ff0;font-weight:bold">0x0884422110</span>)
-------------------------------------------------------------------------------------------------
                                            <span style="color:#ff0;font-weight:bold">0000</span> d000  h000 <span style="color:#ff0;font-weight:bold">0</span>c00  <span style="color:#ff0;font-weight:bold">0</span>g00 <span style="color:#ff0;font-weight:bold">00</span>b0  <span style="color:#ff0;font-weight:bold">00f</span><span style="color:#ff0;font-weight:bold">0</span> <span style="color:#ff0;font-weight:bold">000</span>a  <span style="color:#ff0;font-weight:bold">000</span>e <span style="color:#ff0;font-weight:bold">0000</span>
*                                           <span style="color:#ff0;font-weight:bold">0000</span> <span style="color:#ff0;font-weight:bold">0001</span>  <span style="color:#ff0;font-weight:bold">0000</span> <span style="color:#ff0;font-weight:bold">0001</span>  <span style="color:#ff0;font-weight:bold">0000</span> <span style="color:#ff0;font-weight:bold">0001</span>  <span style="color:#ff0;font-weight:bold">0000</span> <span style="color:#ff0;font-weight:bold">0001</span>  <span style="color:#ff0;font-weight:bold">0000</span> <span style="color:#ff0;font-weight:bold">0001</span> (<span style="color:#ff0;font-weight:bold">0x0101010101</span>)
-------------------------------------------------------------------------------------------------
                                            <span style="color:#ff0;font-weight:bold">0000</span> d000  h000 <span style="color:#ff0;font-weight:bold">0</span>c00  <span style="color:#ff0;font-weight:bold">0</span>g00 <span style="color:#ff0;font-weight:bold">00</span>b0  <span style="color:#ff0;font-weight:bold">00f</span><span style="color:#ff0;font-weight:bold">0</span> <span style="color:#ff0;font-weight:bold">000</span>a  <span style="color:#ff0;font-weight:bold">000</span>e <span style="color:#ff0;font-weight:bold">0000</span>
                                 <span style="color:#ff0;font-weight:bold">0000</span> d000  h000 <span style="color:#ff0;font-weight:bold">0</span>c00  <span style="color:#ff0;font-weight:bold">0</span>g00 <span style="color:#ff0;font-weight:bold">00</span>b0  <span style="color:#ff0;font-weight:bold">00f</span><span style="color:#ff0;font-weight:bold">0</span> <span style="color:#ff0;font-weight:bold">000</span>a  <span style="color:#ff0;font-weight:bold">000</span>e <span style="color:#ff0;font-weight:bold">0000</span>
                      <span style="color:#ff0;font-weight:bold">0000</span> d000  h000 <span style="color:#ff0;font-weight:bold">0</span>c00  <span style="color:#ff0;font-weight:bold">0</span>g00 <span style="color:#ff0;font-weight:bold">00</span>b0  <span style="color:#ff0;font-weight:bold">00f</span><span style="color:#ff0;font-weight:bold">0</span> <span style="color:#ff0;font-weight:bold">000</span>a  <span style="color:#ff0;font-weight:bold">000</span>e <span style="color:#ff0;font-weight:bold">0000</span>
           <span style="color:#ff0;font-weight:bold">0000</span> d000  h000 <span style="color:#ff0;font-weight:bold">0</span>c00  <span style="color:#ff0;font-weight:bold">0</span>g00 <span style="color:#ff0;font-weight:bold">00</span>b0  <span style="color:#ff0;font-weight:bold">00f</span><span style="color:#ff0;font-weight:bold">0</span> <span style="color:#ff0;font-weight:bold">000</span>a  <span style="color:#ff0;font-weight:bold">000</span>e <span style="color:#ff0;font-weight:bold">0000</span>
<span style="color:#ff0;font-weight:bold">0000</span> d000  h000 <span style="color:#ff0;font-weight:bold">0</span>c00  <span style="color:#ff0;font-weight:bold">0</span>g00 <span style="color:#ff0;font-weight:bold">00</span>b0  <span style="color:#ff0;font-weight:bold">00f</span><span style="color:#ff0;font-weight:bold">0</span> <span style="color:#ff0;font-weight:bold">000</span>a  <span style="color:#ff0;font-weight:bold">000</span>e <span style="color:#ff0;font-weight:bold">0000</span>
-------------------------------------------------------------------------------------------------
<span style="color:#ff0;font-weight:bold">0000</span> d000  h000 dc00  hg00 dcb0  hgf0 dcba  hgfe dcba  hgfe <span style="color:#ff0;font-weight:bold">0</span>cba  <span style="color:#ff0;font-weight:bold">0</span>gfe <span style="color:#ff0;font-weight:bold">00</span>ba  <span style="color:#ff0;font-weight:bold">00f</span>e <span style="color:#ff0;font-weight:bold">000</span>a  <span style="color:#ff0;font-weight:bold">000</span>e <span style="color:#ff0;font-weight:bold">0000</span>
&gt;&gt; <span style="color:#ff0;font-weight:bold">32</span>
-------------------------------------------------------------------------------------------------
                                            <span style="color:#ff0;font-weight:bold">0000</span> d000  h000 dc00  hg00 dcb0  hgf0 dcba  hgfe dcba  
&amp;                                                                                       <span style="color:#ff0;font-weight:bold">1111</span> <span style="color:#ff0;font-weight:bold">1111</span>
-------------------------------------------------------------------------------------------------
                                                                                        hgfe dcba  </code></pre></div>
<p>Note that the last two steps can be combined on some processors because the registers can be accessed as bytes; just multiply so that a register stores the upper 32 bits of the result and the take the low byte. Thus, it may take only 6 operations.</p>

<p>Devised by Sean Anderson, July 13, 2001.</p>

<hr />

<h3 id="reverse-the-bits-in-a-byte-with-7-operations-no-64-bit">Reverse the bits in a byte with 7 operations (no 64-bit):</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">b = ((b * <span style="color:#ff0;font-weight:bold">0x0802LU</span> &amp; <span style="color:#ff0;font-weight:bold">0x22110LU</span>) | (b * <span style="color:#ff0;font-weight:bold">0x8020LU</span> &amp; <span style="color:#ff0;font-weight:bold">0x88440LU</span>)) * <span style="color:#ff0;font-weight:bold">0x10101LU</span> &gt;&gt; <span style="color:#ff0;font-weight:bold">16</span>;</code></pre></div>
<p>Make sure you assign or cast the result to an unsigned char to remove garbage in the higher bits. Devised by Sean Anderson, July 13, 2001. Typo spotted and correction supplied by Mike Keith, January 3, 2002.</p>

<hr />

<h3 id="reverse-an-n-bit-quantity-in-parallel-in-5-lg-n-operations">Reverse an N-bit quantity in parallel in 5 * lg(N) operations:</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> v; <span style="color:#007f7f">// 32-bit word to reverse bit order
</span><span style="color:#007f7f"></span>
<span style="color:#007f7f">// swap odd and even bits
</span><span style="color:#007f7f"></span>v = ((v &gt;&gt; <span style="color:#ff0;font-weight:bold">1</span>) &amp; <span style="color:#ff0;font-weight:bold">0x55555555</span>) | ((v &amp; <span style="color:#ff0;font-weight:bold">0x55555555</span>) &lt;&lt; <span style="color:#ff0;font-weight:bold">1</span>);
<span style="color:#007f7f">// swap consecutive pairs
</span><span style="color:#007f7f"></span>v = ((v &gt;&gt; <span style="color:#ff0;font-weight:bold">2</span>) &amp; <span style="color:#ff0;font-weight:bold">0x33333333</span>) | ((v &amp; <span style="color:#ff0;font-weight:bold">0x33333333</span>) &lt;&lt; <span style="color:#ff0;font-weight:bold">2</span>);
<span style="color:#007f7f">// swap nibbles ...
</span><span style="color:#007f7f"></span>v = ((v &gt;&gt; <span style="color:#ff0;font-weight:bold">4</span>) &amp; <span style="color:#ff0;font-weight:bold">0x0F0F0F0F</span>) | ((v &amp; <span style="color:#ff0;font-weight:bold">0x0F0F0F0F</span>) &lt;&lt; <span style="color:#ff0;font-weight:bold">4</span>);
<span style="color:#007f7f">// swap bytes
</span><span style="color:#007f7f"></span>v = ((v &gt;&gt; <span style="color:#ff0;font-weight:bold">8</span>) &amp; <span style="color:#ff0;font-weight:bold">0x00FF00FF</span>) | ((v &amp; <span style="color:#ff0;font-weight:bold">0x00FF00FF</span>) &lt;&lt; <span style="color:#ff0;font-weight:bold">8</span>);
<span style="color:#007f7f">// swap 2-byte long pairs
</span><span style="color:#007f7f"></span>v = ( v &gt;&gt; <span style="color:#ff0;font-weight:bold">16</span>             ) | ( v               &lt;&lt; <span style="color:#ff0;font-weight:bold">16</span>);</code></pre></div>
<p>The following variation is also O(lg(N)), however it requires more operations to reverse v. Its virtue is in taking less slightly memory by computing the constants on the fly.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> s = <span style="color:#fff;font-weight:bold">sizeof</span>(v) * CHAR_BIT; <span style="color:#007f7f">// bit size; must be power of 2
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> mask = ~<span style="color:#ff0;font-weight:bold">0</span>;
<span style="color:#fff;font-weight:bold">while</span> ((s &gt;&gt;= <span style="color:#ff0;font-weight:bold">1</span>) &gt; <span style="color:#ff0;font-weight:bold">0</span>)
{
  mask ^= (mask &lt;&lt; s);
  v = ((v &gt;&gt; s) &amp; mask) | ((v &lt;&lt; s) &amp; ~mask);
}</code></pre></div>
<p>These methods above are best suited to situations where N is large. If you use the above with 64-bit ints (or larger), then you need to add more lines (following the pattern); otherwise only the lower 32 bits will be reversed and the result will be in the lower 32 bits.</p>

<p>See Dr. Dobb&rsquo;s Journal 1983, Edwin Freed&rsquo;s article on Binary Magic Numbers for more information. The second variation was suggested by Ken Raeburn on September 13, 2005. Veldmeijer mentioned that the first version could do without ANDS in the last line on March 19, 2006.</p>

<hr />

<h3 id="compute-modulus-division-by-1-s-without-a-division-operator">Compute modulus division by 1 &lt;&lt; s without a division operator</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> n;          <span style="color:#007f7f">// numerator
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> s;
<span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> d = <span style="color:#ff0;font-weight:bold">1U</span> &lt;&lt; s; <span style="color:#007f7f">// So d will be one of: 1, 2, 4, 8, 16, 32, ...
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> m;                <span style="color:#007f7f">// m will be n % d
</span><span style="color:#007f7f"></span>m = n &amp; (d - <span style="color:#ff0;font-weight:bold">1</span>);</code></pre></div>
<p>Most programmers learn this trick early, but it was included for the sake of completeness.</p>

<hr />

<h3 id="compute-modulus-division-by-1-s-1-without-a-division-operator">Compute modulus division by (1 &lt;&lt; s) - 1 without a division operator</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> n;                      <span style="color:#007f7f">// numerator
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> s;                <span style="color:#007f7f">// s &gt; 0
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> d = (<span style="color:#ff0;font-weight:bold">1</span> &lt;&lt; s) - <span style="color:#ff0;font-weight:bold">1</span>; <span style="color:#007f7f">// so d is either 1, 3, 7, 15, 31, ...).
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> m;                      <span style="color:#007f7f">// n % d goes here.
</span><span style="color:#007f7f"></span>
<span style="color:#fff;font-weight:bold">for</span> (m = n; n &gt; d; n = m)
{
  <span style="color:#fff;font-weight:bold">for</span> (m = <span style="color:#ff0;font-weight:bold">0</span>; n; n &gt;&gt;= s)
  {
    m += n &amp; d;
  }
}
<span style="color:#007f7f">// Now m is a value from 0 to d, but since with modulus division
</span><span style="color:#007f7f">// we want m to be 0 when it is d.
</span><span style="color:#007f7f"></span>m = m == d ? <span style="color:#ff0;font-weight:bold">0</span> : m;</code></pre></div>
<p>This method of modulus division by an integer that is one less than a power of 2 takes at most <code>5 + (4 + 5 * ceil(N / s)) * ceil(lg(N / s))</code> operations, where N is the number of bits in the numerator. In other words, it takes at most O(N * lg(N)) time.</p>

<p>Devised by Sean Anderson, August 15, 2001. Before Sean A. Irvine corrected me on June 17, 2004, I mistakenly commented that we could alternatively assign <code>m = ((m + 1) &amp; d) - 1;</code> at the end. Michael Miller spotted a typo in the code April 25, 2005.</p>

<hr />

<h3 id="compute-modulus-division-by-1-s-1-in-parallel-without-a-division-operator">Compute modulus division by (1 &lt;&lt; s) - 1 in parallel without a division operator</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#007f7f">// The following is for a word size of 32 bits!
</span><span style="color:#007f7f"></span>
<span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> M[] =
{
  <span style="color:#ff0;font-weight:bold">0x00000000</span>, <span style="color:#ff0;font-weight:bold">0x55555555</span>, <span style="color:#ff0;font-weight:bold">0x33333333</span>, <span style="color:#ff0;font-weight:bold">0xc71c71c7</span>,  
  <span style="color:#ff0;font-weight:bold">0x0f0f0f0f</span>, <span style="color:#ff0;font-weight:bold">0xc1f07c1f</span>, <span style="color:#ff0;font-weight:bold">0x3f03f03f</span>, <span style="color:#ff0;font-weight:bold">0xf01fc07f</span>,
  <span style="color:#ff0;font-weight:bold">0x00ff00ff</span>, <span style="color:#ff0;font-weight:bold">0x07fc01ff</span>, <span style="color:#ff0;font-weight:bold">0x3ff003ff</span>, <span style="color:#ff0;font-weight:bold">0xffc007ff</span>,
  <span style="color:#ff0;font-weight:bold">0xff000fff</span>, <span style="color:#ff0;font-weight:bold">0xfc001fff</span>, <span style="color:#ff0;font-weight:bold">0xf0003fff</span>, <span style="color:#ff0;font-weight:bold">0xc0007fff</span>,
  <span style="color:#ff0;font-weight:bold">0x0000ffff</span>, <span style="color:#ff0;font-weight:bold">0x0001ffff</span>, <span style="color:#ff0;font-weight:bold">0x0003ffff</span>, <span style="color:#ff0;font-weight:bold">0x0007ffff</span>,
  <span style="color:#ff0;font-weight:bold">0x000fffff</span>, <span style="color:#ff0;font-weight:bold">0x001fffff</span>, <span style="color:#ff0;font-weight:bold">0x003fffff</span>, <span style="color:#ff0;font-weight:bold">0x007fffff</span>,
  <span style="color:#ff0;font-weight:bold">0x00ffffff</span>, <span style="color:#ff0;font-weight:bold">0x01ffffff</span>, <span style="color:#ff0;font-weight:bold">0x03ffffff</span>, <span style="color:#ff0;font-weight:bold">0x07ffffff</span>,
  <span style="color:#ff0;font-weight:bold">0x0fffffff</span>, <span style="color:#ff0;font-weight:bold">0x1fffffff</span>, <span style="color:#ff0;font-weight:bold">0x3fffffff</span>, <span style="color:#ff0;font-weight:bold">0x7fffffff</span>
};

<span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> Q[][<span style="color:#ff0;font-weight:bold">6</span>] =
{
  { <span style="color:#ff0;font-weight:bold">0</span>,  <span style="color:#ff0;font-weight:bold">0</span>,  <span style="color:#ff0;font-weight:bold">0</span>,  <span style="color:#ff0;font-weight:bold">0</span>,  <span style="color:#ff0;font-weight:bold">0</span>,  <span style="color:#ff0;font-weight:bold">0</span>}, {<span style="color:#ff0;font-weight:bold">16</span>,  <span style="color:#ff0;font-weight:bold">8</span>,  <span style="color:#ff0;font-weight:bold">4</span>,  <span style="color:#ff0;font-weight:bold">2</span>,  <span style="color:#ff0;font-weight:bold">1</span>,  <span style="color:#ff0;font-weight:bold">1</span>}, {<span style="color:#ff0;font-weight:bold">16</span>,  <span style="color:#ff0;font-weight:bold">8</span>,  <span style="color:#ff0;font-weight:bold">4</span>,  <span style="color:#ff0;font-weight:bold">2</span>,  <span style="color:#ff0;font-weight:bold">2</span>,  <span style="color:#ff0;font-weight:bold">2</span>},
  {<span style="color:#ff0;font-weight:bold">15</span>,  <span style="color:#ff0;font-weight:bold">6</span>,  <span style="color:#ff0;font-weight:bold">3</span>,  <span style="color:#ff0;font-weight:bold">3</span>,  <span style="color:#ff0;font-weight:bold">3</span>,  <span style="color:#ff0;font-weight:bold">3</span>}, {<span style="color:#ff0;font-weight:bold">16</span>,  <span style="color:#ff0;font-weight:bold">8</span>,  <span style="color:#ff0;font-weight:bold">4</span>,  <span style="color:#ff0;font-weight:bold">4</span>,  <span style="color:#ff0;font-weight:bold">4</span>,  <span style="color:#ff0;font-weight:bold">4</span>}, {<span style="color:#ff0;font-weight:bold">15</span>,  <span style="color:#ff0;font-weight:bold">5</span>,  <span style="color:#ff0;font-weight:bold">5</span>,  <span style="color:#ff0;font-weight:bold">5</span>,  <span style="color:#ff0;font-weight:bold">5</span>,  <span style="color:#ff0;font-weight:bold">5</span>},
  {<span style="color:#ff0;font-weight:bold">12</span>,  <span style="color:#ff0;font-weight:bold">6</span>,  <span style="color:#ff0;font-weight:bold">6</span>,  <span style="color:#ff0;font-weight:bold">6</span> , <span style="color:#ff0;font-weight:bold">6</span>,  <span style="color:#ff0;font-weight:bold">6</span>}, {<span style="color:#ff0;font-weight:bold">14</span>,  <span style="color:#ff0;font-weight:bold">7</span>,  <span style="color:#ff0;font-weight:bold">7</span>,  <span style="color:#ff0;font-weight:bold">7</span>,  <span style="color:#ff0;font-weight:bold">7</span>,  <span style="color:#ff0;font-weight:bold">7</span>}, {<span style="color:#ff0;font-weight:bold">16</span>,  <span style="color:#ff0;font-weight:bold">8</span>,  <span style="color:#ff0;font-weight:bold">8</span>,  <span style="color:#ff0;font-weight:bold">8</span>,  <span style="color:#ff0;font-weight:bold">8</span>,  <span style="color:#ff0;font-weight:bold">8</span>},
  { <span style="color:#ff0;font-weight:bold">9</span>,  <span style="color:#ff0;font-weight:bold">9</span>,  <span style="color:#ff0;font-weight:bold">9</span>,  <span style="color:#ff0;font-weight:bold">9</span>,  <span style="color:#ff0;font-weight:bold">9</span>,  <span style="color:#ff0;font-weight:bold">9</span>}, {<span style="color:#ff0;font-weight:bold">10</span>, <span style="color:#ff0;font-weight:bold">10</span>, <span style="color:#ff0;font-weight:bold">10</span>, <span style="color:#ff0;font-weight:bold">10</span>, <span style="color:#ff0;font-weight:bold">10</span>, <span style="color:#ff0;font-weight:bold">10</span>}, {<span style="color:#ff0;font-weight:bold">11</span>, <span style="color:#ff0;font-weight:bold">11</span>, <span style="color:#ff0;font-weight:bold">11</span>, <span style="color:#ff0;font-weight:bold">11</span>, <span style="color:#ff0;font-weight:bold">11</span>, <span style="color:#ff0;font-weight:bold">11</span>},
  {<span style="color:#ff0;font-weight:bold">12</span>, <span style="color:#ff0;font-weight:bold">12</span>, <span style="color:#ff0;font-weight:bold">12</span>, <span style="color:#ff0;font-weight:bold">12</span>, <span style="color:#ff0;font-weight:bold">12</span>, <span style="color:#ff0;font-weight:bold">12</span>}, {<span style="color:#ff0;font-weight:bold">13</span>, <span style="color:#ff0;font-weight:bold">13</span>, <span style="color:#ff0;font-weight:bold">13</span>, <span style="color:#ff0;font-weight:bold">13</span>, <span style="color:#ff0;font-weight:bold">13</span>, <span style="color:#ff0;font-weight:bold">13</span>}, {<span style="color:#ff0;font-weight:bold">14</span>, <span style="color:#ff0;font-weight:bold">14</span>, <span style="color:#ff0;font-weight:bold">14</span>, <span style="color:#ff0;font-weight:bold">14</span>, <span style="color:#ff0;font-weight:bold">14</span>, <span style="color:#ff0;font-weight:bold">14</span>},
  {<span style="color:#ff0;font-weight:bold">15</span>, <span style="color:#ff0;font-weight:bold">15</span>, <span style="color:#ff0;font-weight:bold">15</span>, <span style="color:#ff0;font-weight:bold">15</span>, <span style="color:#ff0;font-weight:bold">15</span>, <span style="color:#ff0;font-weight:bold">15</span>}, {<span style="color:#ff0;font-weight:bold">16</span>, <span style="color:#ff0;font-weight:bold">16</span>, <span style="color:#ff0;font-weight:bold">16</span>, <span style="color:#ff0;font-weight:bold">16</span>, <span style="color:#ff0;font-weight:bold">16</span>, <span style="color:#ff0;font-weight:bold">16</span>}, {<span style="color:#ff0;font-weight:bold">17</span>, <span style="color:#ff0;font-weight:bold">17</span>, <span style="color:#ff0;font-weight:bold">17</span>, <span style="color:#ff0;font-weight:bold">17</span>, <span style="color:#ff0;font-weight:bold">17</span>, <span style="color:#ff0;font-weight:bold">17</span>},
  {<span style="color:#ff0;font-weight:bold">18</span>, <span style="color:#ff0;font-weight:bold">18</span>, <span style="color:#ff0;font-weight:bold">18</span>, <span style="color:#ff0;font-weight:bold">18</span>, <span style="color:#ff0;font-weight:bold">18</span>, <span style="color:#ff0;font-weight:bold">18</span>}, {<span style="color:#ff0;font-weight:bold">19</span>, <span style="color:#ff0;font-weight:bold">19</span>, <span style="color:#ff0;font-weight:bold">19</span>, <span style="color:#ff0;font-weight:bold">19</span>, <span style="color:#ff0;font-weight:bold">19</span>, <span style="color:#ff0;font-weight:bold">19</span>}, {<span style="color:#ff0;font-weight:bold">20</span>, <span style="color:#ff0;font-weight:bold">20</span>, <span style="color:#ff0;font-weight:bold">20</span>, <span style="color:#ff0;font-weight:bold">20</span>, <span style="color:#ff0;font-weight:bold">20</span>, <span style="color:#ff0;font-weight:bold">20</span>},
  {<span style="color:#ff0;font-weight:bold">21</span>, <span style="color:#ff0;font-weight:bold">21</span>, <span style="color:#ff0;font-weight:bold">21</span>, <span style="color:#ff0;font-weight:bold">21</span>, <span style="color:#ff0;font-weight:bold">21</span>, <span style="color:#ff0;font-weight:bold">21</span>}, {<span style="color:#ff0;font-weight:bold">22</span>, <span style="color:#ff0;font-weight:bold">22</span>, <span style="color:#ff0;font-weight:bold">22</span>, <span style="color:#ff0;font-weight:bold">22</span>, <span style="color:#ff0;font-weight:bold">22</span>, <span style="color:#ff0;font-weight:bold">22</span>}, {<span style="color:#ff0;font-weight:bold">23</span>, <span style="color:#ff0;font-weight:bold">23</span>, <span style="color:#ff0;font-weight:bold">23</span>, <span style="color:#ff0;font-weight:bold">23</span>, <span style="color:#ff0;font-weight:bold">23</span>, <span style="color:#ff0;font-weight:bold">23</span>},
  {<span style="color:#ff0;font-weight:bold">24</span>, <span style="color:#ff0;font-weight:bold">24</span>, <span style="color:#ff0;font-weight:bold">24</span>, <span style="color:#ff0;font-weight:bold">24</span>, <span style="color:#ff0;font-weight:bold">24</span>, <span style="color:#ff0;font-weight:bold">24</span>}, {<span style="color:#ff0;font-weight:bold">25</span>, <span style="color:#ff0;font-weight:bold">25</span>, <span style="color:#ff0;font-weight:bold">25</span>, <span style="color:#ff0;font-weight:bold">25</span>, <span style="color:#ff0;font-weight:bold">25</span>, <span style="color:#ff0;font-weight:bold">25</span>}, {<span style="color:#ff0;font-weight:bold">26</span>, <span style="color:#ff0;font-weight:bold">26</span>, <span style="color:#ff0;font-weight:bold">26</span>, <span style="color:#ff0;font-weight:bold">26</span>, <span style="color:#ff0;font-weight:bold">26</span>, <span style="color:#ff0;font-weight:bold">26</span>},
  {<span style="color:#ff0;font-weight:bold">27</span>, <span style="color:#ff0;font-weight:bold">27</span>, <span style="color:#ff0;font-weight:bold">27</span>, <span style="color:#ff0;font-weight:bold">27</span>, <span style="color:#ff0;font-weight:bold">27</span>, <span style="color:#ff0;font-weight:bold">27</span>}, {<span style="color:#ff0;font-weight:bold">28</span>, <span style="color:#ff0;font-weight:bold">28</span>, <span style="color:#ff0;font-weight:bold">28</span>, <span style="color:#ff0;font-weight:bold">28</span>, <span style="color:#ff0;font-weight:bold">28</span>, <span style="color:#ff0;font-weight:bold">28</span>}, {<span style="color:#ff0;font-weight:bold">29</span>, <span style="color:#ff0;font-weight:bold">29</span>, <span style="color:#ff0;font-weight:bold">29</span>, <span style="color:#ff0;font-weight:bold">29</span>, <span style="color:#ff0;font-weight:bold">29</span>, <span style="color:#ff0;font-weight:bold">29</span>},
  {<span style="color:#ff0;font-weight:bold">30</span>, <span style="color:#ff0;font-weight:bold">30</span>, <span style="color:#ff0;font-weight:bold">30</span>, <span style="color:#ff0;font-weight:bold">30</span>, <span style="color:#ff0;font-weight:bold">30</span>, <span style="color:#ff0;font-weight:bold">30</span>}, {<span style="color:#ff0;font-weight:bold">31</span>, <span style="color:#ff0;font-weight:bold">31</span>, <span style="color:#ff0;font-weight:bold">31</span>, <span style="color:#ff0;font-weight:bold">31</span>, <span style="color:#ff0;font-weight:bold">31</span>, <span style="color:#ff0;font-weight:bold">31</span>}
};

<span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> R[][<span style="color:#ff0;font-weight:bold">6</span>] =
{
  {<span style="color:#ff0;font-weight:bold">0x00000000</span>, <span style="color:#ff0;font-weight:bold">0x00000000</span>, <span style="color:#ff0;font-weight:bold">0x00000000</span>, <span style="color:#ff0;font-weight:bold">0x00000000</span>, <span style="color:#ff0;font-weight:bold">0x00000000</span>, <span style="color:#ff0;font-weight:bold">0x00000000</span>},
  {<span style="color:#ff0;font-weight:bold">0x0000ffff</span>, <span style="color:#ff0;font-weight:bold">0x000000ff</span>, <span style="color:#ff0;font-weight:bold">0x0000000f</span>, <span style="color:#ff0;font-weight:bold">0x00000003</span>, <span style="color:#ff0;font-weight:bold">0x00000001</span>, <span style="color:#ff0;font-weight:bold">0x00000001</span>},
  {<span style="color:#ff0;font-weight:bold">0x0000ffff</span>, <span style="color:#ff0;font-weight:bold">0x000000ff</span>, <span style="color:#ff0;font-weight:bold">0x0000000f</span>, <span style="color:#ff0;font-weight:bold">0x00000003</span>, <span style="color:#ff0;font-weight:bold">0x00000003</span>, <span style="color:#ff0;font-weight:bold">0x00000003</span>},
  {<span style="color:#ff0;font-weight:bold">0x00007fff</span>, <span style="color:#ff0;font-weight:bold">0x0000003f</span>, <span style="color:#ff0;font-weight:bold">0x00000007</span>, <span style="color:#ff0;font-weight:bold">0x00000007</span>, <span style="color:#ff0;font-weight:bold">0x00000007</span>, <span style="color:#ff0;font-weight:bold">0x00000007</span>},
  {<span style="color:#ff0;font-weight:bold">0x0000ffff</span>, <span style="color:#ff0;font-weight:bold">0x000000ff</span>, <span style="color:#ff0;font-weight:bold">0x0000000f</span>, <span style="color:#ff0;font-weight:bold">0x0000000f</span>, <span style="color:#ff0;font-weight:bold">0x0000000f</span>, <span style="color:#ff0;font-weight:bold">0x0000000f</span>},
  {<span style="color:#ff0;font-weight:bold">0x00007fff</span>, <span style="color:#ff0;font-weight:bold">0x0000001f</span>, <span style="color:#ff0;font-weight:bold">0x0000001f</span>, <span style="color:#ff0;font-weight:bold">0x0000001f</span>, <span style="color:#ff0;font-weight:bold">0x0000001f</span>, <span style="color:#ff0;font-weight:bold">0x0000001f</span>},
  {<span style="color:#ff0;font-weight:bold">0x00000fff</span>, <span style="color:#ff0;font-weight:bold">0x0000003f</span>, <span style="color:#ff0;font-weight:bold">0x0000003f</span>, <span style="color:#ff0;font-weight:bold">0x0000003f</span>, <span style="color:#ff0;font-weight:bold">0x0000003f</span>, <span style="color:#ff0;font-weight:bold">0x0000003f</span>},
  {<span style="color:#ff0;font-weight:bold">0x00003fff</span>, <span style="color:#ff0;font-weight:bold">0x0000007f</span>, <span style="color:#ff0;font-weight:bold">0x0000007f</span>, <span style="color:#ff0;font-weight:bold">0x0000007f</span>, <span style="color:#ff0;font-weight:bold">0x0000007f</span>, <span style="color:#ff0;font-weight:bold">0x0000007f</span>},
  {<span style="color:#ff0;font-weight:bold">0x0000ffff</span>, <span style="color:#ff0;font-weight:bold">0x000000ff</span>, <span style="color:#ff0;font-weight:bold">0x000000ff</span>, <span style="color:#ff0;font-weight:bold">0x000000ff</span>, <span style="color:#ff0;font-weight:bold">0x000000ff</span>, <span style="color:#ff0;font-weight:bold">0x000000ff</span>},
  {<span style="color:#ff0;font-weight:bold">0x000001ff</span>, <span style="color:#ff0;font-weight:bold">0x000001ff</span>, <span style="color:#ff0;font-weight:bold">0x000001ff</span>, <span style="color:#ff0;font-weight:bold">0x000001ff</span>, <span style="color:#ff0;font-weight:bold">0x000001ff</span>, <span style="color:#ff0;font-weight:bold">0x000001ff</span>},
  {<span style="color:#ff0;font-weight:bold">0x000003ff</span>, <span style="color:#ff0;font-weight:bold">0x000003ff</span>, <span style="color:#ff0;font-weight:bold">0x000003ff</span>, <span style="color:#ff0;font-weight:bold">0x000003ff</span>, <span style="color:#ff0;font-weight:bold">0x000003ff</span>, <span style="color:#ff0;font-weight:bold">0x000003ff</span>},
  {<span style="color:#ff0;font-weight:bold">0x000007ff</span>, <span style="color:#ff0;font-weight:bold">0x000007ff</span>, <span style="color:#ff0;font-weight:bold">0x000007ff</span>, <span style="color:#ff0;font-weight:bold">0x000007ff</span>, <span style="color:#ff0;font-weight:bold">0x000007ff</span>, <span style="color:#ff0;font-weight:bold">0x000007ff</span>},
  {<span style="color:#ff0;font-weight:bold">0x00000fff</span>, <span style="color:#ff0;font-weight:bold">0x00000fff</span>, <span style="color:#ff0;font-weight:bold">0x00000fff</span>, <span style="color:#ff0;font-weight:bold">0x00000fff</span>, <span style="color:#ff0;font-weight:bold">0x00000fff</span>, <span style="color:#ff0;font-weight:bold">0x00000fff</span>},
  {<span style="color:#ff0;font-weight:bold">0x00001fff</span>, <span style="color:#ff0;font-weight:bold">0x00001fff</span>, <span style="color:#ff0;font-weight:bold">0x00001fff</span>, <span style="color:#ff0;font-weight:bold">0x00001fff</span>, <span style="color:#ff0;font-weight:bold">0x00001fff</span>, <span style="color:#ff0;font-weight:bold">0x00001fff</span>},
  {<span style="color:#ff0;font-weight:bold">0x00003fff</span>, <span style="color:#ff0;font-weight:bold">0x00003fff</span>, <span style="color:#ff0;font-weight:bold">0x00003fff</span>, <span style="color:#ff0;font-weight:bold">0x00003fff</span>, <span style="color:#ff0;font-weight:bold">0x00003fff</span>, <span style="color:#ff0;font-weight:bold">0x00003fff</span>},
  {<span style="color:#ff0;font-weight:bold">0x00007fff</span>, <span style="color:#ff0;font-weight:bold">0x00007fff</span>, <span style="color:#ff0;font-weight:bold">0x00007fff</span>, <span style="color:#ff0;font-weight:bold">0x00007fff</span>, <span style="color:#ff0;font-weight:bold">0x00007fff</span>, <span style="color:#ff0;font-weight:bold">0x00007fff</span>},
  {<span style="color:#ff0;font-weight:bold">0x0000ffff</span>, <span style="color:#ff0;font-weight:bold">0x0000ffff</span>, <span style="color:#ff0;font-weight:bold">0x0000ffff</span>, <span style="color:#ff0;font-weight:bold">0x0000ffff</span>, <span style="color:#ff0;font-weight:bold">0x0000ffff</span>, <span style="color:#ff0;font-weight:bold">0x0000ffff</span>},
  {<span style="color:#ff0;font-weight:bold">0x0001ffff</span>, <span style="color:#ff0;font-weight:bold">0x0001ffff</span>, <span style="color:#ff0;font-weight:bold">0x0001ffff</span>, <span style="color:#ff0;font-weight:bold">0x0001ffff</span>, <span style="color:#ff0;font-weight:bold">0x0001ffff</span>, <span style="color:#ff0;font-weight:bold">0x0001ffff</span>},
  {<span style="color:#ff0;font-weight:bold">0x0003ffff</span>, <span style="color:#ff0;font-weight:bold">0x0003ffff</span>, <span style="color:#ff0;font-weight:bold">0x0003ffff</span>, <span style="color:#ff0;font-weight:bold">0x0003ffff</span>, <span style="color:#ff0;font-weight:bold">0x0003ffff</span>, <span style="color:#ff0;font-weight:bold">0x0003ffff</span>},
  {<span style="color:#ff0;font-weight:bold">0x0007ffff</span>, <span style="color:#ff0;font-weight:bold">0x0007ffff</span>, <span style="color:#ff0;font-weight:bold">0x0007ffff</span>, <span style="color:#ff0;font-weight:bold">0x0007ffff</span>, <span style="color:#ff0;font-weight:bold">0x0007ffff</span>, <span style="color:#ff0;font-weight:bold">0x0007ffff</span>},
  {<span style="color:#ff0;font-weight:bold">0x000fffff</span>, <span style="color:#ff0;font-weight:bold">0x000fffff</span>, <span style="color:#ff0;font-weight:bold">0x000fffff</span>, <span style="color:#ff0;font-weight:bold">0x000fffff</span>, <span style="color:#ff0;font-weight:bold">0x000fffff</span>, <span style="color:#ff0;font-weight:bold">0x000fffff</span>},
  {<span style="color:#ff0;font-weight:bold">0x001fffff</span>, <span style="color:#ff0;font-weight:bold">0x001fffff</span>, <span style="color:#ff0;font-weight:bold">0x001fffff</span>, <span style="color:#ff0;font-weight:bold">0x001fffff</span>, <span style="color:#ff0;font-weight:bold">0x001fffff</span>, <span style="color:#ff0;font-weight:bold">0x001fffff</span>},
  {<span style="color:#ff0;font-weight:bold">0x003fffff</span>, <span style="color:#ff0;font-weight:bold">0x003fffff</span>, <span style="color:#ff0;font-weight:bold">0x003fffff</span>, <span style="color:#ff0;font-weight:bold">0x003fffff</span>, <span style="color:#ff0;font-weight:bold">0x003fffff</span>, <span style="color:#ff0;font-weight:bold">0x003fffff</span>},
  {<span style="color:#ff0;font-weight:bold">0x007fffff</span>, <span style="color:#ff0;font-weight:bold">0x007fffff</span>, <span style="color:#ff0;font-weight:bold">0x007fffff</span>, <span style="color:#ff0;font-weight:bold">0x007fffff</span>, <span style="color:#ff0;font-weight:bold">0x007fffff</span>, <span style="color:#ff0;font-weight:bold">0x007fffff</span>},
  {<span style="color:#ff0;font-weight:bold">0x00ffffff</span>, <span style="color:#ff0;font-weight:bold">0x00ffffff</span>, <span style="color:#ff0;font-weight:bold">0x00ffffff</span>, <span style="color:#ff0;font-weight:bold">0x00ffffff</span>, <span style="color:#ff0;font-weight:bold">0x00ffffff</span>, <span style="color:#ff0;font-weight:bold">0x00ffffff</span>},
  {<span style="color:#ff0;font-weight:bold">0x01ffffff</span>, <span style="color:#ff0;font-weight:bold">0x01ffffff</span>, <span style="color:#ff0;font-weight:bold">0x01ffffff</span>, <span style="color:#ff0;font-weight:bold">0x01ffffff</span>, <span style="color:#ff0;font-weight:bold">0x01ffffff</span>, <span style="color:#ff0;font-weight:bold">0x01ffffff</span>},
  {<span style="color:#ff0;font-weight:bold">0x03ffffff</span>, <span style="color:#ff0;font-weight:bold">0x03ffffff</span>, <span style="color:#ff0;font-weight:bold">0x03ffffff</span>, <span style="color:#ff0;font-weight:bold">0x03ffffff</span>, <span style="color:#ff0;font-weight:bold">0x03ffffff</span>, <span style="color:#ff0;font-weight:bold">0x03ffffff</span>},
  {<span style="color:#ff0;font-weight:bold">0x07ffffff</span>, <span style="color:#ff0;font-weight:bold">0x07ffffff</span>, <span style="color:#ff0;font-weight:bold">0x07ffffff</span>, <span style="color:#ff0;font-weight:bold">0x07ffffff</span>, <span style="color:#ff0;font-weight:bold">0x07ffffff</span>, <span style="color:#ff0;font-weight:bold">0x07ffffff</span>},
  {<span style="color:#ff0;font-weight:bold">0x0fffffff</span>, <span style="color:#ff0;font-weight:bold">0x0fffffff</span>, <span style="color:#ff0;font-weight:bold">0x0fffffff</span>, <span style="color:#ff0;font-weight:bold">0x0fffffff</span>, <span style="color:#ff0;font-weight:bold">0x0fffffff</span>, <span style="color:#ff0;font-weight:bold">0x0fffffff</span>},
  {<span style="color:#ff0;font-weight:bold">0x1fffffff</span>, <span style="color:#ff0;font-weight:bold">0x1fffffff</span>, <span style="color:#ff0;font-weight:bold">0x1fffffff</span>, <span style="color:#ff0;font-weight:bold">0x1fffffff</span>, <span style="color:#ff0;font-weight:bold">0x1fffffff</span>, <span style="color:#ff0;font-weight:bold">0x1fffffff</span>},
  {<span style="color:#ff0;font-weight:bold">0x3fffffff</span>, <span style="color:#ff0;font-weight:bold">0x3fffffff</span>, <span style="color:#ff0;font-weight:bold">0x3fffffff</span>, <span style="color:#ff0;font-weight:bold">0x3fffffff</span>, <span style="color:#ff0;font-weight:bold">0x3fffffff</span>, <span style="color:#ff0;font-weight:bold">0x3fffffff</span>},
  {<span style="color:#ff0;font-weight:bold">0x7fffffff</span>, <span style="color:#ff0;font-weight:bold">0x7fffffff</span>, <span style="color:#ff0;font-weight:bold">0x7fffffff</span>, <span style="color:#ff0;font-weight:bold">0x7fffffff</span>, <span style="color:#ff0;font-weight:bold">0x7fffffff</span>, <span style="color:#ff0;font-weight:bold">0x7fffffff</span>}
};

<span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> n;       <span style="color:#007f7f">// numerator
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> s; <span style="color:#007f7f">// s &gt; 0
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> d = (<span style="color:#ff0;font-weight:bold">1</span> &lt;&lt; s) - <span style="color:#ff0;font-weight:bold">1</span>; <span style="color:#007f7f">// so d is either 1, 3, 7, 15, 31, ...).
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> m;       <span style="color:#007f7f">// n % d goes here.
</span><span style="color:#007f7f"></span>
m = (n &amp; M[s]) + ((n &gt;&gt; s) &amp; M[s]);

<span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> * q = &amp;Q[s][<span style="color:#ff0;font-weight:bold">0</span>], * r = &amp;R[s][<span style="color:#ff0;font-weight:bold">0</span>]; m &gt; d; q++, r++)
{
  m = (m &gt;&gt; *q) + (m &amp; *r);
}
m = m == d ? <span style="color:#ff0;font-weight:bold">0</span> : m; // OR, less portably: m = m &amp; -((<span style="color:#fff;font-weight:bold">signed</span>)(m - d) &gt;&gt; s);</code></pre></div>
<p>This method of finding modulus division by an integer that is one less than a power of 2 takes at most O(lg(N)) time, where N is the number of bits in the numerator (32 bits, for the code above). The number of operations is at most 12 + 9 * ceil(lg(N)). The tables may be removed if you know the denominator at compile time; just extract the few relevent entries and unroll the loop. It may be easily extended to more bits.</p>

<p>It finds the result by summing the values in base (1 &lt;&lt; s) in parallel. First every other base (1 &lt;&lt; s) value is added to the previous one. Imagine that the result is written on a piece of paper. Cut the paper in half, so that half the values are on each cut piece. Align the values and sum them onto a new piece of paper. Repeat by cutting this paper in half (which will be a quarter of the size of the previous one) and summing, until you cannot cut further. After performing lg(N/s/2) cuts, we cut no more; just continue to add the values and put the result onto a new piece of paper as before, while there are at least two s-bit values.</p>

<p>Devised by Sean Anderson, August 20, 2001. A typo was spotted by Randy E. Bryant on May 3, 2005 (after pasting the code, I had later added &ldquo;unsinged&rdquo; to a variable declaration). As in the previous hack, I mistakenly commented that we could alternatively assign <code>m = ((m + 1) &amp; d) - 1;</code> at the end, and Don Knuth corrected me on April 19, 2006 and suggested <code>m = m &amp; -((signed)(m - d) &gt;&gt; s)</code>. On June 18, 2009 Sean Irvine proposed a change that used <code>((n &gt;&gt; s) &amp; M[s])</code> instead of <code>((n &amp; ~M[s]) &gt;&gt; s)</code>, which typically requires fewer operations because the M[s] constant is already loaded.</p>

<hr />

<h3 id="find-the-log-base-2-of-an-integer-with-the-msb-n-set-in-o-n-operations-the-obvious-way">Find the log base 2 of an integer with the MSB N set in O(N) operations (the obvious way)</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> v; <span style="color:#007f7f">// 32-bit word to find the log base 2 of
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> r = <span style="color:#ff0;font-weight:bold">0</span>; <span style="color:#007f7f">// r will be lg(v)
</span><span style="color:#007f7f"></span>
<span style="color:#fff;font-weight:bold">while</span> (v &gt;&gt;= <span style="color:#ff0;font-weight:bold">1</span>) <span style="color:#007f7f">// unroll for more speed...
</span><span style="color:#007f7f"></span>{
  r++;
}</code></pre></div>
<p>The log base 2 of an integer is the same as the position of the highest bit set (or most significant bit set, MSB). The following log base 2 methods are faster than this one.</p>

<hr />

<h3 id="find-the-integer-log-base-2-of-an-integer-with-an-64-bit-ieee-float">Find the integer log base 2 of an integer with an 64-bit IEEE float</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">int</span> v; <span style="color:#007f7f">// 32-bit integer to find the log base 2 of
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">int</span> r; <span style="color:#007f7f">// result of log_2(v) goes here
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">union</span> { <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> u[<span style="color:#ff0;font-weight:bold">2</span>]; <span style="color:#fff;font-weight:bold">double</span> d; } t; <span style="color:#007f7f">// temp
</span><span style="color:#007f7f"></span>
t.u[__FLOAT_WORD_ORDER==LITTLE_ENDIAN] = <span style="color:#ff0;font-weight:bold">0x43300000</span>;
t.u[__FLOAT_WORD_ORDER!=LITTLE_ENDIAN] = v;
t.d -= <span style="color:#ff0;font-weight:bold">4503599627370496.0</span>;
r = (t.u[__FLOAT_WORD_ORDER==LITTLE_ENDIAN] &gt;&gt; <span style="color:#ff0;font-weight:bold">20</span>) - <span style="color:#ff0;font-weight:bold">0x3FF</span>;</code></pre></div>
<p>The code above loads a 64-bit (IEEE-754 floating-point) double with a 32-bit integer (with no paddding bits) by storing the integer in the mantissa while the exponent is set to 252. From this newly minted double, 252 (expressed as a double) is subtracted, which sets the resulting exponent to the log base 2 of the input value, v. All that is left is shifting the exponent bits into position (20 bits right) and subtracting the bias, 0x3FF (which is 1023 decimal). This technique only takes 5 operations, but many CPUs are slow at manipulating doubles, and the endianess of the architecture must be accommodated.</p>

<p>Eric Cole sent me this on January 15, 2006. Evan Felix pointed out a typo on April 4, 2006. Vincent Lefèvre told me on July 9, 2008 to change the endian check to use the float&rsquo;s endian, which could differ from the integer&rsquo;s endian.</p>

<hr />

<h3 id="find-the-log-base-2-of-an-integer-with-a-lookup-table">Find the log base 2 of an integer with a lookup table</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">char</span> LogTable256[<span style="color:#ff0;font-weight:bold">256</span>] =
{
<span style="color:#0f0;font-weight:bold">#define LT(n) n, n, n, n, n, n, n, n, n, n, n, n, n, n, n, n
</span><span style="color:#0f0;font-weight:bold"></span>    -<span style="color:#ff0;font-weight:bold">1</span>, <span style="color:#ff0;font-weight:bold">0</span>, <span style="color:#ff0;font-weight:bold">1</span>, <span style="color:#ff0;font-weight:bold">1</span>, <span style="color:#ff0;font-weight:bold">2</span>, <span style="color:#ff0;font-weight:bold">2</span>, <span style="color:#ff0;font-weight:bold">2</span>, <span style="color:#ff0;font-weight:bold">2</span>, <span style="color:#ff0;font-weight:bold">3</span>, <span style="color:#ff0;font-weight:bold">3</span>, <span style="color:#ff0;font-weight:bold">3</span>, <span style="color:#ff0;font-weight:bold">3</span>, <span style="color:#ff0;font-weight:bold">3</span>, <span style="color:#ff0;font-weight:bold">3</span>, <span style="color:#ff0;font-weight:bold">3</span>, <span style="color:#ff0;font-weight:bold">3</span>,
    LT(<span style="color:#ff0;font-weight:bold">4</span>), LT(<span style="color:#ff0;font-weight:bold">5</span>), LT(<span style="color:#ff0;font-weight:bold">5</span>), LT(<span style="color:#ff0;font-weight:bold">6</span>), LT(<span style="color:#ff0;font-weight:bold">6</span>), LT(<span style="color:#ff0;font-weight:bold">6</span>), LT(<span style="color:#ff0;font-weight:bold">6</span>),
    LT(<span style="color:#ff0;font-weight:bold">7</span>), LT(<span style="color:#ff0;font-weight:bold">7</span>), LT(<span style="color:#ff0;font-weight:bold">7</span>), LT(<span style="color:#ff0;font-weight:bold">7</span>), LT(<span style="color:#ff0;font-weight:bold">7</span>), LT(<span style="color:#ff0;font-weight:bold">7</span>), LT(<span style="color:#ff0;font-weight:bold">7</span>), LT(<span style="color:#ff0;font-weight:bold">7</span>)
};

<span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> v; <span style="color:#007f7f">// 32-bit word to find the log of
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">unsigned</span> r;     <span style="color:#007f7f">// r will be lg(v)
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">register</span> <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> t, tt; <span style="color:#007f7f">// temporaries
</span><span style="color:#007f7f"></span>
<span style="color:#fff;font-weight:bold">if</span> (tt = v &gt;&gt; <span style="color:#ff0;font-weight:bold">16</span>)
{
  r = (t = tt &gt;&gt; <span style="color:#ff0;font-weight:bold">8</span>) ? <span style="color:#ff0;font-weight:bold">24</span> + LogTable256[t] : <span style="color:#ff0;font-weight:bold">16</span> + LogTable256[tt];
}
<span style="color:#fff;font-weight:bold">else</span>
{
  r = (t = v &gt;&gt; <span style="color:#ff0;font-weight:bold">8</span>) ? <span style="color:#ff0;font-weight:bold">8</span> + LogTable256[t] : LogTable256[v];
}</code></pre></div>
<p>The lookup table method takes only about 7 operations to find the log of a 32-bit value. If extended for 64-bit quantities, it would take roughly 9 operations. Another operation can be trimmed off by using four tables, with the possible additions incorporated into each. Using int table elements may be faster, depending on your architecture.</p>

<p>The code above is tuned to uniformly distributed <em>output</em> values. If your <em>inputs</em> are evenly distributed across all 32-bit values, then consider using the following:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">if</span> (tt = v &gt;&gt; <span style="color:#ff0;font-weight:bold">24</span>)
{
  r = <span style="color:#ff0;font-weight:bold">24</span> + LogTable256[tt];
}
<span style="color:#fff;font-weight:bold">else</span> <span style="color:#fff;font-weight:bold">if</span> (tt = v &gt;&gt; <span style="color:#ff0;font-weight:bold">16</span>)
{
  r = <span style="color:#ff0;font-weight:bold">16</span> + LogTable256[tt];
}
<span style="color:#fff;font-weight:bold">else</span> <span style="color:#fff;font-weight:bold">if</span> (tt = v &gt;&gt; <span style="color:#ff0;font-weight:bold">8</span>)
{
  r = <span style="color:#ff0;font-weight:bold">8</span> + LogTable256[tt];
}
<span style="color:#fff;font-weight:bold">else</span>
{
  r = LogTable256[v];
}</code></pre></div>
<p>To initially generate the log table algorithmically:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">LogTable256[<span style="color:#ff0;font-weight:bold">0</span>] = LogTable256[<span style="color:#ff0;font-weight:bold">1</span>] = <span style="color:#ff0;font-weight:bold">0</span>;
<span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">2</span>; i &lt; <span style="color:#ff0;font-weight:bold">256</span>; i++)
{
  LogTable256[i] = <span style="color:#ff0;font-weight:bold">1</span> + LogTable256[i / <span style="color:#ff0;font-weight:bold">2</span>];
}
LogTable256[<span style="color:#ff0;font-weight:bold">0</span>] = -<span style="color:#ff0;font-weight:bold">1</span>; // <span style="color:#fff;font-weight:bold">if</span> you want log(<span style="color:#ff0;font-weight:bold">0</span>) to <span style="color:#fff;font-weight:bold">return</span> -<span style="color:#ff0;font-weight:bold">1</span></code></pre></div>
<p>Behdad Esfahbod and I shaved off a fraction of an operation (on average) on May 18, 2005. Yet another fraction of an operation was removed on November 14, 2006 by Emanuel Hoogeveen. The variation that is tuned to evenly distributed input values was suggested by David A. Butterfield on September 19, 2008. Venkat Reddy told me on January 5, 2009 that log(0) should return -1 to indicate an error, so I changed the first entry in the table to that.</p>

<hr />

<h3 id="find-the-log-base-2-of-an-n-bit-integer-in-o-lg-n-operations">Find the log base 2 of an N-bit integer in O(lg(N)) operations</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> v;  <span style="color:#007f7f">// 32-bit value to find the log2 of
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> b[] = {<span style="color:#ff0;font-weight:bold">0x2</span>, <span style="color:#ff0;font-weight:bold">0xC</span>, <span style="color:#ff0;font-weight:bold">0xF0</span>, <span style="color:#ff0;font-weight:bold">0xFF00</span>, <span style="color:#ff0;font-weight:bold">0xFFFF0000</span>};
<span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> S[] = {<span style="color:#ff0;font-weight:bold">1</span>, <span style="color:#ff0;font-weight:bold">2</span>, <span style="color:#ff0;font-weight:bold">4</span>, <span style="color:#ff0;font-weight:bold">8</span>, <span style="color:#ff0;font-weight:bold">16</span>};
<span style="color:#fff;font-weight:bold">int</span> i;

<span style="color:#fff;font-weight:bold">register</span> <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> r = <span style="color:#ff0;font-weight:bold">0</span>; <span style="color:#007f7f">// result of log2(v) will go here
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">for</span> (i = <span style="color:#ff0;font-weight:bold">4</span>; i &gt;= <span style="color:#ff0;font-weight:bold">0</span>; i--) <span style="color:#007f7f">// unroll for speed...
</span><span style="color:#007f7f"></span>{
  <span style="color:#fff;font-weight:bold">if</span> (v &amp; b[i])
  {
    v &gt;&gt;= S[i];
    r |= S[i];
  }
}


<span style="color:#007f7f">// OR (IF YOUR CPU BRANCHES SLOWLY):
</span><span style="color:#007f7f"></span>
<span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> v;          <span style="color:#007f7f">// 32-bit value to find the log2 of
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">register</span> <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> r; <span style="color:#007f7f">// result of log2(v) will go here
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">register</span> <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> shift;

r =     (v &gt; <span style="color:#ff0;font-weight:bold">0xFFFF</span>) &lt;&lt; <span style="color:#ff0;font-weight:bold">4</span>; v &gt;&gt;= r;
shift = (v &gt; <span style="color:#ff0;font-weight:bold">0xFF</span>  ) &lt;&lt; <span style="color:#ff0;font-weight:bold">3</span>; v &gt;&gt;= shift; r |= shift;
shift = (v &gt; <span style="color:#ff0;font-weight:bold">0xF</span>   ) &lt;&lt; <span style="color:#ff0;font-weight:bold">2</span>; v &gt;&gt;= shift; r |= shift;
shift = (v &gt; <span style="color:#ff0;font-weight:bold">0x3</span>   ) &lt;&lt; <span style="color:#ff0;font-weight:bold">1</span>; v &gt;&gt;= shift; r |= shift;
                                        r |= (v &gt;&gt; <span style="color:#ff0;font-weight:bold">1</span>);


<span style="color:#007f7f">// OR (IF YOU KNOW v IS A POWER OF 2):
</span><span style="color:#007f7f"></span>
<span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> v;  <span style="color:#007f7f">// 32-bit value to find the log2 of 
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> b[] = {<span style="color:#ff0;font-weight:bold">0xAAAAAAAA</span>, <span style="color:#ff0;font-weight:bold">0xCCCCCCCC</span>, <span style="color:#ff0;font-weight:bold">0xF0F0F0F0</span>,
                                 <span style="color:#ff0;font-weight:bold">0xFF00FF00</span>, <span style="color:#ff0;font-weight:bold">0xFFFF0000</span>};
<span style="color:#fff;font-weight:bold">register</span> <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> r = (v &amp; b[<span style="color:#ff0;font-weight:bold">0</span>]) != <span style="color:#ff0;font-weight:bold">0</span>;
<span style="color:#fff;font-weight:bold">for</span> (i = <span style="color:#ff0;font-weight:bold">4</span>; i &gt; <span style="color:#ff0;font-weight:bold">0</span>; i--) <span style="color:#007f7f">// unroll for speed...
</span><span style="color:#007f7f"></span>{
  r |= ((v &amp; b[i]) != <span style="color:#ff0;font-weight:bold">0</span>) &lt;&lt; i;
}</code></pre></div>
<p>Of course, to extend the code to find the log of a 33- to 64-bit number, we would append another element, 0xFFFFFFFF00000000, to b, append 32 to S, and loop from 5 to 0. This method is much slower than the earlier table-lookup version, but if you don&rsquo;t want big table or your architecture is slow to access memory, it&rsquo;s a good choice. The second variation involves slightly more operations, but it may be faster on machines with high branch costs (e.g. PowerPC).</p>

<p>The second version was sent to me by <a href="http://www.balance-software.com/ec/">Eric Cole</a> on January 7, 2006. Andrew Shapira subsequently trimmed a few operations off of it and sent me his variation (above) on Sept. 1, 2007. The third variation was suggested to me by <a href="http://www.ece.ucdavis.edu/~jowens/">John Owens</a> on April 24, 2002; it&rsquo;s faster, but <em>it is only suitable when the input is known to be a power of 2</em>. On May 25, 2003, Ken Raeburn suggested improving the general case by using smaller numbers for b[], which load faster on some architectures (for instance if the word size is 16 bits, then only one load instruction may be needed). These values work for the general version, but not for the special-case version below it, where v is a power of 2; Glenn Slayden brought this oversight to my attention on December 12, 2003.</p>

<hr />

<h3 id="find-the-log-base-2-of-an-n-bit-integer-in-o-lg-n-operations-with-multiply-and-lookup">Find the log base 2 of an N-bit integer in O(lg(N)) operations with multiply and lookup</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">uint32_t v; <span style="color:#007f7f">// find the log base 2 of 32-bit v
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">int</span> r;      <span style="color:#007f7f">// result goes here
</span><span style="color:#007f7f"></span>
<span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">int</span> MultiplyDeBruijnBitPosition[<span style="color:#ff0;font-weight:bold">32</span>] =
{
  <span style="color:#ff0;font-weight:bold">0</span>, <span style="color:#ff0;font-weight:bold">9</span>, <span style="color:#ff0;font-weight:bold">1</span>, <span style="color:#ff0;font-weight:bold">10</span>, <span style="color:#ff0;font-weight:bold">13</span>, <span style="color:#ff0;font-weight:bold">21</span>, <span style="color:#ff0;font-weight:bold">2</span>, <span style="color:#ff0;font-weight:bold">29</span>, <span style="color:#ff0;font-weight:bold">11</span>, <span style="color:#ff0;font-weight:bold">14</span>, <span style="color:#ff0;font-weight:bold">16</span>, <span style="color:#ff0;font-weight:bold">18</span>, <span style="color:#ff0;font-weight:bold">22</span>, <span style="color:#ff0;font-weight:bold">25</span>, <span style="color:#ff0;font-weight:bold">3</span>, <span style="color:#ff0;font-weight:bold">30</span>,
  <span style="color:#ff0;font-weight:bold">8</span>, <span style="color:#ff0;font-weight:bold">12</span>, <span style="color:#ff0;font-weight:bold">20</span>, <span style="color:#ff0;font-weight:bold">28</span>, <span style="color:#ff0;font-weight:bold">15</span>, <span style="color:#ff0;font-weight:bold">17</span>, <span style="color:#ff0;font-weight:bold">24</span>, <span style="color:#ff0;font-weight:bold">7</span>, <span style="color:#ff0;font-weight:bold">19</span>, <span style="color:#ff0;font-weight:bold">27</span>, <span style="color:#ff0;font-weight:bold">23</span>, <span style="color:#ff0;font-weight:bold">6</span>, <span style="color:#ff0;font-weight:bold">26</span>, <span style="color:#ff0;font-weight:bold">5</span>, <span style="color:#ff0;font-weight:bold">4</span>, <span style="color:#ff0;font-weight:bold">31</span>
};

v |= v &gt;&gt; <span style="color:#ff0;font-weight:bold">1</span>; <span style="color:#007f7f">// first round down to one less than a power of 2
</span><span style="color:#007f7f"></span>v |= v &gt;&gt; <span style="color:#ff0;font-weight:bold">2</span>;
v |= v &gt;&gt; <span style="color:#ff0;font-weight:bold">4</span>;
v |= v &gt;&gt; <span style="color:#ff0;font-weight:bold">8</span>;
v |= v &gt;&gt; <span style="color:#ff0;font-weight:bold">16</span>;

r = MultiplyDeBruijnBitPosition[(uint32_t)(v * <span style="color:#ff0;font-weight:bold">0x07C4ACDDU</span>) &gt;&gt; <span style="color:#ff0;font-weight:bold">27</span>];</code></pre></div>
<p>The code above computes the log base 2 of a 32-bit integer with a small table lookup and multiply. It requires only 13 operations, compared to (up to) 20 for the previous method. The purely table-based method requires the fewest operations, but this offers a reasonable compromise between table size and speed.</p>

<p>If you know that v is a power of 2, then you only need the following:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">int</span> MultiplyDeBruijnBitPosition2[<span style="color:#ff0;font-weight:bold">32</span>] =
{
  <span style="color:#ff0;font-weight:bold">0</span>, <span style="color:#ff0;font-weight:bold">1</span>, <span style="color:#ff0;font-weight:bold">28</span>, <span style="color:#ff0;font-weight:bold">2</span>, <span style="color:#ff0;font-weight:bold">29</span>, <span style="color:#ff0;font-weight:bold">14</span>, <span style="color:#ff0;font-weight:bold">24</span>, <span style="color:#ff0;font-weight:bold">3</span>, <span style="color:#ff0;font-weight:bold">30</span>, <span style="color:#ff0;font-weight:bold">22</span>, <span style="color:#ff0;font-weight:bold">20</span>, <span style="color:#ff0;font-weight:bold">15</span>, <span style="color:#ff0;font-weight:bold">25</span>, <span style="color:#ff0;font-weight:bold">17</span>, <span style="color:#ff0;font-weight:bold">4</span>, <span style="color:#ff0;font-weight:bold">8</span>,
  <span style="color:#ff0;font-weight:bold">31</span>, <span style="color:#ff0;font-weight:bold">27</span>, <span style="color:#ff0;font-weight:bold">13</span>, <span style="color:#ff0;font-weight:bold">23</span>, <span style="color:#ff0;font-weight:bold">21</span>, <span style="color:#ff0;font-weight:bold">19</span>, <span style="color:#ff0;font-weight:bold">16</span>, <span style="color:#ff0;font-weight:bold">7</span>, <span style="color:#ff0;font-weight:bold">26</span>, <span style="color:#ff0;font-weight:bold">12</span>, <span style="color:#ff0;font-weight:bold">18</span>, <span style="color:#ff0;font-weight:bold">6</span>, <span style="color:#ff0;font-weight:bold">11</span>, <span style="color:#ff0;font-weight:bold">5</span>, <span style="color:#ff0;font-weight:bold">10</span>, <span style="color:#ff0;font-weight:bold">9</span>
};
r = MultiplyDeBruijnBitPosition2[(uint32_t)(v * <span style="color:#ff0;font-weight:bold">0x077CB531U</span>) &gt;&gt; <span style="color:#ff0;font-weight:bold">27</span>];</code></pre></div>
<p>Eric Cole devised this January 8, 2006 after reading about the entry below to <a href="#RoundUpPowerOf2">round up to a power of 2</a> and the method below for <a href="#ZerosOnRightMultLookup">computing the number of trailing bits with a multiply and lookup</a> using a DeBruijn sequence. On December 10, 2009, Mark Dickinson shaved off a couple operations by requiring v be rounded up to one less than the next power of 2 rather than the power of 2.</p>

<hr />

<h3 id="find-integer-log-base-10-of-an-integer">Find integer log base 10 of an integer</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> v; <span style="color:#007f7f">// non-zero 32-bit integer value to compute the log base 10 of
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">int</span> r;          <span style="color:#007f7f">// result goes here
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">int</span> t;          <span style="color:#007f7f">// temporary
</span><span style="color:#007f7f"></span>
<span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> <span style="color:#fff;font-weight:bold">const</span> PowersOf10[] =
    {<span style="color:#ff0;font-weight:bold">1</span>, <span style="color:#ff0;font-weight:bold">10</span>, <span style="color:#ff0;font-weight:bold">100</span>, <span style="color:#ff0;font-weight:bold">1000</span>, <span style="color:#ff0;font-weight:bold">10000</span>, <span style="color:#ff0;font-weight:bold">100000</span>,
     <span style="color:#ff0;font-weight:bold">1000000</span>, <span style="color:#ff0;font-weight:bold">10000000</span>, <span style="color:#ff0;font-weight:bold">100000000</span>, <span style="color:#ff0;font-weight:bold">1000000000</span>};

t = (IntegerLogBase2(v) + <span style="color:#ff0;font-weight:bold">1</span>) * <span style="color:#ff0;font-weight:bold">1233</span> &gt;&gt; <span style="color:#ff0;font-weight:bold">12</span>; <span style="color:#007f7f">// (use a lg2 method from above)
</span><span style="color:#007f7f"></span>r = t - (v &lt; PowersOf10[t]);</code></pre></div>
<p>The integer log base 10 is computed by first using one of the techniques above for finding the log base 2. By the relationship log10(v) = log2(v) / log2(10), we need to multiply it by 1/log2(10), which is approximately <sup>1233</sup>&frasl;<sub>4096</sub>, or 1233 followed by a right shift of 12. Adding one is needed because the IntegerLogBase2 rounds down. Finally, since the value t is only an approximation that may be off by one, the exact value is found by subtracting the result of v &lt; PowersOf10[t].</p>

<p>This method takes 6 more operations than IntegerLogBase2. It may be sped up (on machines with fast memory access) by modifying the log base 2 table-lookup method above so that the entries hold what is computed for t (that is, pre-add, -mulitply, and -shift). Doing so would require a total of only 9 operations to find the log base 10, assuming 4 tables were used (one for each byte of v).</p>

<p>Eric Cole suggested I add a version of this on January 7, 2006.</p>

<hr />

<h3 id="find-integer-log-base-10-of-an-integer-the-obvious-way">Find integer log base 10 of an integer the obvious way</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> v; <span style="color:#007f7f">// non-zero 32-bit integer value to compute the log base 10 of
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">int</span> r;          <span style="color:#007f7f">// result goes here
</span><span style="color:#007f7f"></span>
r = (v &gt;= <span style="color:#ff0;font-weight:bold">1000000000</span>) ? <span style="color:#ff0;font-weight:bold">9</span> : (v &gt;= <span style="color:#ff0;font-weight:bold">100000000</span>) ? <span style="color:#ff0;font-weight:bold">8</span> : (v &gt;= <span style="color:#ff0;font-weight:bold">10000000</span>) ? <span style="color:#ff0;font-weight:bold">7</span> : 
    (v &gt;= <span style="color:#ff0;font-weight:bold">1000000</span>) ? <span style="color:#ff0;font-weight:bold">6</span> : (v &gt;= <span style="color:#ff0;font-weight:bold">100000</span>) ? <span style="color:#ff0;font-weight:bold">5</span> : (v &gt;= <span style="color:#ff0;font-weight:bold">10000</span>) ? <span style="color:#ff0;font-weight:bold">4</span> : 
    (v &gt;= <span style="color:#ff0;font-weight:bold">1000</span>) ? <span style="color:#ff0;font-weight:bold">3</span> : (v &gt;= <span style="color:#ff0;font-weight:bold">100</span>) ? <span style="color:#ff0;font-weight:bold">2</span> : (v &gt;= <span style="color:#ff0;font-weight:bold">10</span>) ? <span style="color:#ff0;font-weight:bold">1</span> : <span style="color:#ff0;font-weight:bold">0</span>;</code></pre></div>
<p>This method works well when the input is uniformly distributed over 32-bit values because 76% of the inputs are caught by the first compare, 21% are caught by the second compare, 2% are caught by the third, and so on (chopping the remaining down by 90% with each comparision). As a result, less than 2.6 operations are needed on average.</p>

<p>On April 18, 2007, Emanuel Hoogeveen suggested a variation on this where the conditions used divisions, which were not as fast as simple comparisons.</p>

<hr />

<h3 id="find-integer-log-base-2-of-a-32-bit-ieee-float">Find integer log base 2 of a 32-bit IEEE float</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">float</span> v; <span style="color:#007f7f">// find int(log2(v)), where v &gt; 0.0 &amp;&amp; finite(v) &amp;&amp; isnormal(v)
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">int</span> c;         <span style="color:#007f7f">// 32-bit int c gets the result;
</span><span style="color:#007f7f"></span>
c = *(<span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">int</span> *) &amp;v;  <span style="color:#007f7f">// OR, for portability:  memcpy(&amp;c, &amp;v, sizeof c);
</span><span style="color:#007f7f"></span>c = (c &gt;&gt; <span style="color:#ff0;font-weight:bold">23</span>) - <span style="color:#ff0;font-weight:bold">127</span>;</code></pre></div>
<p>The above is fast, but IEEE 754-compliant architectures utilize <em>subnormal</em> (also called <em>denormal</em>) floating point numbers. These have the exponent bits set to zero (signifying pow(2,-127)), and the mantissa is not normalized, so it contains leading zeros and thus the log2 must be computed from the mantissa. To accomodate for subnormal numbers, use the following:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">float</span> v;              <span style="color:#007f7f">// find int(log2(v)), where v &gt; 0.0 &amp;&amp; finite(v)
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">int</span> c;                      <span style="color:#007f7f">// 32-bit int c gets the result;
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">int</span> x = *(<span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">int</span> *) &amp;v;  <span style="color:#007f7f">// OR, for portability:  memcpy(&amp;x, &amp;v, sizeof x);
</span><span style="color:#007f7f"></span>
c = x &gt;&gt; <span style="color:#ff0;font-weight:bold">23</span>;

<span style="color:#fff;font-weight:bold">if</span> (c)
{
  c -= <span style="color:#ff0;font-weight:bold">127</span>;
}
<span style="color:#fff;font-weight:bold">else</span>
{ <span style="color:#007f7f">// subnormal, so recompute using mantissa: c = intlog2(x) - 149;
</span><span style="color:#007f7f"></span>  <span style="color:#fff;font-weight:bold">register</span> <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> t; <span style="color:#007f7f">// temporary
</span><span style="color:#007f7f"></span>  <span style="color:#007f7f">// Note that LogTable256 was defined [earlier](#IntegerLogLookup)
</span><span style="color:#007f7f"></span>  <span style="color:#fff;font-weight:bold">if</span> (t = x &gt;&gt; <span style="color:#ff0;font-weight:bold">16</span>)
  {
    c = LogTable256[t] - <span style="color:#ff0;font-weight:bold">133</span>;
  }
  <span style="color:#fff;font-weight:bold">else</span>
  {
    c = (t = x &gt;&gt; <span style="color:#ff0;font-weight:bold">8</span>) ? LogTable256[t] - <span style="color:#ff0;font-weight:bold">141</span> : LogTable256[x] - <span style="color:#ff0;font-weight:bold">149</span>;
  }
}</code></pre></div>
<p>On June 20, 2004, Sean A. Irvine suggested that I include code to handle subnormal numbers. On June 11, 2005, Falk Hüffner pointed out that ISO C99 6.<sup>5</sup>&frasl;<sub>7</sub> specified undefined behavior for the common type punning idiom *(int *)&amp;, though it has worked on 99.9% of C compilers. He proposed using memcpy for maximum portability or a union with a float and an int for better code generation than memcpy on some compilers.</p>

<hr />

<h3 id="find-integer-log-base-2-of-the-pow-2-r-root-of-a-32-bit-ieee-float-for-unsigned-integer-r">Find integer log base 2 of the pow(2, r)-root of a 32-bit IEEE float (for unsigned integer r)</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">int</span> r;
<span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">float</span> v; <span style="color:#007f7f">// find int(log2(pow((double) v, 1. / pow(2, r)))),
</span><span style="color:#007f7f"></span>               <span style="color:#007f7f">// where isnormal(v) and v &gt; 0
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">int</span> c;         <span style="color:#007f7f">// 32-bit int c gets the result;
</span><span style="color:#007f7f"></span>
c = *(<span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">int</span> *) &amp;v;  <span style="color:#007f7f">// OR, for portability:  memcpy(&amp;c, &amp;v, sizeof c);
</span><span style="color:#007f7f"></span>c = ((((c - <span style="color:#ff0;font-weight:bold">0x3f800000</span>) &gt;&gt; r) + <span style="color:#ff0;font-weight:bold">0x3f800000</span>) &gt;&gt; <span style="color:#ff0;font-weight:bold">23</span>) - <span style="color:#ff0;font-weight:bold">127</span>;</code></pre></div>
<p>So, if r is 0, for example, we have c = int(log2((double) v)). If r is 1, then we have c = int(log2(sqrt((double) v))). If r is 2, then we have c = int(log2(pow((double) v, 1./4))).</p>

<p>On June 11, 2005, Falk Hüffner pointed out that ISO C99 6.<sup>5</sup>&frasl;<sub>7</sub> left the type punning idiom *(int *)&amp; undefined, and he suggested using memcpy.</p>

<hr />

<h3 id="count-the-consecutive-zero-bits-trailing-on-the-right-linearly">Count the consecutive zero bits (trailing) on the right linearly</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> v;  <span style="color:#007f7f">// input to count trailing zero bits
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">int</span> c;  <span style="color:#007f7f">// output: c will count v&#39;s trailing zero bits,
</span><span style="color:#007f7f"></span>        <span style="color:#007f7f">// so if v is 1101000 (base 2), then c will be 3
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">if</span> (v)
{
  v = (v ^ (v - <span style="color:#ff0;font-weight:bold">1</span>)) &gt;&gt; <span style="color:#ff0;font-weight:bold">1</span>;  <span style="color:#007f7f">// Set v&#39;s trailing 0s to 1s and zero rest
</span><span style="color:#007f7f"></span>  <span style="color:#fff;font-weight:bold">for</span> (c = <span style="color:#ff0;font-weight:bold">0</span>; v; c++)
  {
    v &gt;&gt;= <span style="color:#ff0;font-weight:bold">1</span>;
  }
}
<span style="color:#fff;font-weight:bold">else</span>
{
  c = CHAR_BIT * <span style="color:#fff;font-weight:bold">sizeof</span>(v);
}</code></pre></div>
<p>The average number of trailing zero bits in a (uniformly distributed) random binary number is one, so this O(trailing zeros) solution isn&rsquo;t that bad compared to the faster methods below.</p>

<p>Jim Cole suggested I add a linear-time method for counting the trailing zeros on August 15, 2007. On October 22, 2007, Jason Cunningham pointed out that I had neglected to paste the unsigned modifier for v.</p>

<hr />

<h3 id="count-the-consecutive-zero-bits-trailing-on-the-right-in-parallel">Count the consecutive zero bits (trailing) on the right in parallel</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> v;      <span style="color:#007f7f">// 32-bit word input to count zero bits on right
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> c = <span style="color:#ff0;font-weight:bold">32</span>; <span style="color:#007f7f">// c will be the number of zero bits on the right
</span><span style="color:#007f7f"></span>v &amp;= -<span style="color:#fff;font-weight:bold">signed</span>(v);
<span style="color:#fff;font-weight:bold">if</span> (v) c--;
<span style="color:#fff;font-weight:bold">if</span> (v &amp; <span style="color:#ff0;font-weight:bold">0x0000FFFF</span>) c -= <span style="color:#ff0;font-weight:bold">16</span>;
<span style="color:#fff;font-weight:bold">if</span> (v &amp; <span style="color:#ff0;font-weight:bold">0x00FF00FF</span>) c -= <span style="color:#ff0;font-weight:bold">8</span>;
<span style="color:#fff;font-weight:bold">if</span> (v &amp; <span style="color:#ff0;font-weight:bold">0x0F0F0F0F</span>) c -= <span style="color:#ff0;font-weight:bold">4</span>;
<span style="color:#fff;font-weight:bold">if</span> (v &amp; <span style="color:#ff0;font-weight:bold">0x33333333</span>) c -= <span style="color:#ff0;font-weight:bold">2</span>;
<span style="color:#fff;font-weight:bold">if</span> (v &amp; <span style="color:#ff0;font-weight:bold">0x55555555</span>) c -= <span style="color:#ff0;font-weight:bold">1</span>;</code></pre></div>
<p>Here, we are basically doing the same operations as finding the log base 2 in parallel, but we first isolate the lowest 1 bit, and then proceed with c starting at the maximum and decreasing. The number of operations is at most 3 * lg(N) + 4, roughly, for N bit words.</p>

<p>Bill Burdick suggested an optimization, reducing the time from 4 * lg(N) on February 4, 2011.</p>

<hr />

<h3 id="count-the-consecutive-zero-bits-trailing-on-the-right-by-binary-search">Count the consecutive zero bits (trailing) on the right by binary search</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> v;     <span style="color:#007f7f">// 32-bit word input to count zero bits on right
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> c;     <span style="color:#007f7f">// c will be the number of zero bits on the right,
</span><span style="color:#007f7f"></span>                    <span style="color:#007f7f">// so if v is 1101000 (base 2), then c will be 3
</span><span style="color:#007f7f">// NOTE: if 0 == v, then c = 31.
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">if</span> (v &amp; <span style="color:#ff0;font-weight:bold">0x1</span>)
{
  <span style="color:#007f7f">// special case for odd v (assumed to happen half of the time)
</span><span style="color:#007f7f"></span>  c = <span style="color:#ff0;font-weight:bold">0</span>;
}
<span style="color:#fff;font-weight:bold">else</span>
{
  c = <span style="color:#ff0;font-weight:bold">1</span>;
  <span style="color:#fff;font-weight:bold">if</span> ((v &amp; <span style="color:#ff0;font-weight:bold">0xffff</span>) == <span style="color:#ff0;font-weight:bold">0</span>)
  {  
    v &gt;&gt;= <span style="color:#ff0;font-weight:bold">16</span>;  
    c += <span style="color:#ff0;font-weight:bold">16</span>;
  }
  <span style="color:#fff;font-weight:bold">if</span> ((v &amp; <span style="color:#ff0;font-weight:bold">0xff</span>) == <span style="color:#ff0;font-weight:bold">0</span>)
  {  
    v &gt;&gt;= <span style="color:#ff0;font-weight:bold">8</span>;  
    c += <span style="color:#ff0;font-weight:bold">8</span>;
  }
  <span style="color:#fff;font-weight:bold">if</span> ((v &amp; <span style="color:#ff0;font-weight:bold">0xf</span>) == <span style="color:#ff0;font-weight:bold">0</span>)
  {  
    v &gt;&gt;= <span style="color:#ff0;font-weight:bold">4</span>;
    c += <span style="color:#ff0;font-weight:bold">4</span>;
  }
  <span style="color:#fff;font-weight:bold">if</span> ((v &amp; <span style="color:#ff0;font-weight:bold">0x3</span>) == <span style="color:#ff0;font-weight:bold">0</span>)
  {  
    v &gt;&gt;= <span style="color:#ff0;font-weight:bold">2</span>;
    c += <span style="color:#ff0;font-weight:bold">2</span>;
  }
  c -= v &amp; <span style="color:#ff0;font-weight:bold">0x1</span>;
}</code></pre></div>
<p>The code above is similar to the previous method, but it computes the number of trailing zeros by accumulating c in a manner akin to binary search. In the first step, it checks if the bottom 16 bits of v are zeros, and if so, shifts v right 16 bits and adds 16 to c, which reduces the number of bits in v to consider by half. Each of the subsequent conditional steps likewise halves the number of bits until there is only 1. This method is faster than the last one (by about 33%) because the bodies of the if statements are executed less often.</p>

<p>Matt Whitlock suggested this on January 25, 2006. Andrew Shapira shaved a couple operations off on Sept. 5, 2007 (by setting c=1 and unconditionally subtracting at the end).</p>

<hr />

<h3 id="count-the-consecutive-zero-bits-trailing-on-the-right-by-casting-to-a-float">Count the consecutive zero bits (trailing) on the right by casting to a float</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> v;            <span style="color:#007f7f">// find the number of trailing zeros in v
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">int</span> r;                     <span style="color:#007f7f">// the result goes here
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">float</span> f = (<span style="color:#fff;font-weight:bold">float</span>)(v &amp; -v); <span style="color:#007f7f">// cast the least significant bit in v to a float
</span><span style="color:#007f7f"></span>r = (*(uint32_t *)&amp;f &gt;&gt; <span style="color:#ff0;font-weight:bold">23</span>) - <span style="color:#ff0;font-weight:bold">0x7f</span>;</code></pre></div>
<p>Although this only takes about 6 operations, the time to convert an integer to a float can be high on some machines. The exponent of the 32-bit IEEE floating point representation is shifted down, and the bias is subtracted to give the position of the least significant 1 bit set in v. If v is zero, then the result is -127.</p>

<hr />

<h3 id="count-the-consecutive-zero-bits-trailing-on-the-right-with-modulus-division-and-lookup">Count the consecutive zero bits (trailing) on the right with modulus division and lookup</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> v;  <span style="color:#007f7f">// find the number of trailing zeros in v
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">int</span> r;           <span style="color:#007f7f">// put the result in r
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">int</span> Mod37BitPosition[] = <span style="color:#007f7f">// map a bit value mod 37 to its position
</span><span style="color:#007f7f"></span>{
  <span style="color:#ff0;font-weight:bold">32</span>, <span style="color:#ff0;font-weight:bold">0</span>, <span style="color:#ff0;font-weight:bold">1</span>, <span style="color:#ff0;font-weight:bold">26</span>, <span style="color:#ff0;font-weight:bold">2</span>, <span style="color:#ff0;font-weight:bold">23</span>, <span style="color:#ff0;font-weight:bold">27</span>, <span style="color:#ff0;font-weight:bold">0</span>, <span style="color:#ff0;font-weight:bold">3</span>, <span style="color:#ff0;font-weight:bold">16</span>, <span style="color:#ff0;font-weight:bold">24</span>, <span style="color:#ff0;font-weight:bold">30</span>, <span style="color:#ff0;font-weight:bold">28</span>, <span style="color:#ff0;font-weight:bold">11</span>, <span style="color:#ff0;font-weight:bold">0</span>, <span style="color:#ff0;font-weight:bold">13</span>, <span style="color:#ff0;font-weight:bold">4</span>,
  <span style="color:#ff0;font-weight:bold">7</span>, <span style="color:#ff0;font-weight:bold">17</span>, <span style="color:#ff0;font-weight:bold">0</span>, <span style="color:#ff0;font-weight:bold">25</span>, <span style="color:#ff0;font-weight:bold">22</span>, <span style="color:#ff0;font-weight:bold">31</span>, <span style="color:#ff0;font-weight:bold">15</span>, <span style="color:#ff0;font-weight:bold">29</span>, <span style="color:#ff0;font-weight:bold">10</span>, <span style="color:#ff0;font-weight:bold">12</span>, <span style="color:#ff0;font-weight:bold">6</span>, <span style="color:#ff0;font-weight:bold">0</span>, <span style="color:#ff0;font-weight:bold">21</span>, <span style="color:#ff0;font-weight:bold">14</span>, <span style="color:#ff0;font-weight:bold">9</span>, <span style="color:#ff0;font-weight:bold">5</span>,
  <span style="color:#ff0;font-weight:bold">20</span>, <span style="color:#ff0;font-weight:bold">8</span>, <span style="color:#ff0;font-weight:bold">19</span>, <span style="color:#ff0;font-weight:bold">18</span>
};
r = Mod37BitPosition[(-v &amp; v) % <span style="color:#ff0;font-weight:bold">37</span>];</code></pre></div>
<p>The code above finds the number of zeros that are trailing on the right, so binary 0100 would produce 2. It makes use of the fact that the first 32 bit position values are relatively prime with 37, so performing a modulus division with 37 gives a unique number from 0 to 36 for each. These numbers may then be mapped to the number of zeros using a small lookup table. It uses only 4 operations, however indexing into a table and performing modulus division may make it unsuitable for some situations. I came up with this independently and then searched for a subsequence of the table values, and found it was invented earlier by Reiser, according to <a href="http://www.hackersdelight.org/HDcode/ntz.c.txt">Hacker&rsquo;s Delight</a>.</p>

<hr />

<h3 id="count-the-consecutive-zero-bits-trailing-on-the-right-with-multiply-and-lookup">Count the consecutive zero bits (trailing) on the right with multiply and lookup</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> v;  <span style="color:#007f7f">// find the number of trailing zeros in 32-bit v
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">int</span> r;           <span style="color:#007f7f">// result goes here
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">int</span> MultiplyDeBruijnBitPosition[<span style="color:#ff0;font-weight:bold">32</span>] =
{
  <span style="color:#ff0;font-weight:bold">0</span>, <span style="color:#ff0;font-weight:bold">1</span>, <span style="color:#ff0;font-weight:bold">28</span>, <span style="color:#ff0;font-weight:bold">2</span>, <span style="color:#ff0;font-weight:bold">29</span>, <span style="color:#ff0;font-weight:bold">14</span>, <span style="color:#ff0;font-weight:bold">24</span>, <span style="color:#ff0;font-weight:bold">3</span>, <span style="color:#ff0;font-weight:bold">30</span>, <span style="color:#ff0;font-weight:bold">22</span>, <span style="color:#ff0;font-weight:bold">20</span>, <span style="color:#ff0;font-weight:bold">15</span>, <span style="color:#ff0;font-weight:bold">25</span>, <span style="color:#ff0;font-weight:bold">17</span>, <span style="color:#ff0;font-weight:bold">4</span>, <span style="color:#ff0;font-weight:bold">8</span>,
  <span style="color:#ff0;font-weight:bold">31</span>, <span style="color:#ff0;font-weight:bold">27</span>, <span style="color:#ff0;font-weight:bold">13</span>, <span style="color:#ff0;font-weight:bold">23</span>, <span style="color:#ff0;font-weight:bold">21</span>, <span style="color:#ff0;font-weight:bold">19</span>, <span style="color:#ff0;font-weight:bold">16</span>, <span style="color:#ff0;font-weight:bold">7</span>, <span style="color:#ff0;font-weight:bold">26</span>, <span style="color:#ff0;font-weight:bold">12</span>, <span style="color:#ff0;font-weight:bold">18</span>, <span style="color:#ff0;font-weight:bold">6</span>, <span style="color:#ff0;font-weight:bold">11</span>, <span style="color:#ff0;font-weight:bold">5</span>, <span style="color:#ff0;font-weight:bold">10</span>, <span style="color:#ff0;font-weight:bold">9</span>
};
r = MultiplyDeBruijnBitPosition[((uint32_t)((v &amp; -v) * <span style="color:#ff0;font-weight:bold">0x077CB531U</span>)) &gt;&gt; <span style="color:#ff0;font-weight:bold">27</span>];</code></pre></div>
<p>Converting bit vectors to indices of set bits is an example use for this. It requires one more operation than the earlier one involving modulus division, but the multiply may be faster. The expression (v &amp; -v) extracts the least significant 1 bit from v. The constant 0x077CB531UL is a de Bruijn sequence, which produces a unique pattern of bits into the high 5 bits for each possible bit position that it is multiplied against. When there are no bits set, it returns 0. More information can be found by reading the paper <a href="http://citeseer.ist.psu.edu/leiserson98using.html">Using de Bruijn Sequences to Index 1 in a Computer Word</a> by Charles E. Leiserson, Harald Prokof, and Keith H. Randall.</p>

<p>On October 8, 2005 <a href="http://onezero.org">Andrew Shapira</a> suggested I add this. Dustin Spicuzza asked me on April 14, 2009 to cast the result of the multiply to a 32-bit type so it would work when compiled with 64-bit ints.</p>

<hr />

<h3 id="round-up-to-the-next-highest-power-of-2-by-float-casting">Round up to the next highest power of 2 by float casting</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> <span style="color:#fff;font-weight:bold">const</span> v; <span style="color:#007f7f">// Round this 32-bit value to the next highest power of 2
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> r;       <span style="color:#007f7f">// Put the result here. (So v=3 -&gt; r=4; v=8 -&gt; r=8)
</span><span style="color:#007f7f"></span>
<span style="color:#fff;font-weight:bold">if</span> (v &gt; <span style="color:#ff0;font-weight:bold">1</span>)
{
  <span style="color:#fff;font-weight:bold">float</span> f = (<span style="color:#fff;font-weight:bold">float</span>)v;
  <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> <span style="color:#fff;font-weight:bold">const</span> t = <span style="color:#ff0;font-weight:bold">1U</span> &lt;&lt; ((*(<span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> *)&amp;f &gt;&gt; <span style="color:#ff0;font-weight:bold">23</span>) - <span style="color:#ff0;font-weight:bold">0x7f</span>);
  r = t &lt;&lt; (t &lt; v);
}
<span style="color:#fff;font-weight:bold">else</span> 
{
  r = <span style="color:#ff0;font-weight:bold">1</span>;
}</code></pre></div>
<p>The code above uses 8 operations, but works on all v &lt;= (1&lt;&lt;31).</p>

<p>Quick and dirty version, for domain of 1 &lt; v &lt; (1&lt;&lt;25):</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">float</span> f = (<span style="color:#fff;font-weight:bold">float</span>)(v - <span style="color:#ff0;font-weight:bold">1</span>);  
r = <span style="color:#ff0;font-weight:bold">1U</span> &lt;&lt; ((*(<span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span>*)(&amp;f) &gt;&gt; <span style="color:#ff0;font-weight:bold">23</span>) - <span style="color:#ff0;font-weight:bold">126</span>);</code></pre></div>
<p>Although the quick and dirty version only uses around 6 operations, it is roughly three times slower than the <a href="#RoundUpPowerOf2">technique below</a> (which involves 12 operations) when benchmarked on an Athlon™ XP 2100+ CPU. Some CPUs will fare better with it, though.</p>

<p>On September 27, 2005 Andi Smithers suggested I include a technique for casting to floats to find the lg of a number for rounding up to a power of 2. Similar to the quick and dirty version here, his version worked with values less than (1&lt;&lt;25), due to mantissa rounding, but it used one more operation.</p>

<hr />

<h3 id="round-up-to-the-next-highest-power-of-2">Round up to the next highest power of 2</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> v; <span style="color:#007f7f">// compute the next highest power of 2 of 32-bit v
</span><span style="color:#007f7f"></span>
v--;
v |= v &gt;&gt; <span style="color:#ff0;font-weight:bold">1</span>;
v |= v &gt;&gt; <span style="color:#ff0;font-weight:bold">2</span>;
v |= v &gt;&gt; <span style="color:#ff0;font-weight:bold">4</span>;
v |= v &gt;&gt; <span style="color:#ff0;font-weight:bold">8</span>;
v |= v &gt;&gt; <span style="color:#ff0;font-weight:bold">16</span>;
v++;</code></pre></div>
<p>In 12 operations, this code computes the next highest power of 2 for a 32-bit integer. The result may be expressed by the formula 1U &lt;&lt; (lg(v - 1) + 1). Note that in the edge case where v is 0, it returns 0, which isn&rsquo;t a power of 2; you might append the expression v += (v == 0) to remedy this if it matters. It would be faster by 2 operations to use the formula and the log base 2 method that uses a lookup table, but in some situations, lookup tables are not suitable, so the above code may be best. (On a Athlon™ XP 2100+ I&rsquo;ve found the above shift-left and then OR code is as fast as using a single BSR assembly language instruction, which scans in reverse to find the highest set bit.) It works by copying the highest set bit to all of the lower bits, and then adding one, which results in carries that set all of the lower bits to 0 and one bit beyond the highest set bit to 1. If the original number was a power of 2, then the decrement will reduce it to one less, so that we round up to the same original value.</p>

<p>You might alternatively compute the next higher power of 2 in only 8 or 9 operations using a lookup table for floor(lg(v)) and then evaluating 1&lt;&lt;(1+floor(lg(v))); Atul Divekar suggested I mention this on September 5, 2010.</p>

<p>Devised by Sean Anderson, Sepember 14, 2001. Pete Hart pointed me to <a href="http://groups.google.com/group/comp.lang.python/browse_thread/thread/c4d3aae0df917df5/6fdae3872f9de79d?lnk=st&amp;q=comp.lang.python+zeddy&amp;rnum=6#6fdae3872f9de79d">a couple newsgroup posts</a> by him and William Lewis in February of 1997, where they arrive at the same algorithm.</p>

<hr />

<h3 id="interleave-bits-the-obvious-way">Interleave bits the obvious way</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">short</span> x;   <span style="color:#007f7f">// Interleave bits of x and y, so that all of the
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">short</span> y;   <span style="color:#007f7f">// bits of x are in the even positions and y in the odd;
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> z = <span style="color:#ff0;font-weight:bold">0</span>; <span style="color:#007f7f">// z gets the resulting Morton Number.
</span><span style="color:#007f7f"></span>
<span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">0</span>; i &lt; <span style="color:#fff;font-weight:bold">sizeof</span>(x) * CHAR_BIT; i++) <span style="color:#007f7f">// unroll for more speed...
</span><span style="color:#007f7f"></span>{
  z |= (x &amp; <span style="color:#ff0;font-weight:bold">1U</span> &lt;&lt; i) &lt;&lt; i | (y &amp; <span style="color:#ff0;font-weight:bold">1U</span> &lt;&lt; i) &lt;&lt; (i + <span style="color:#ff0;font-weight:bold">1</span>);
}</code></pre></div>
<p>Interleaved bits (aka Morton numbers) are useful for linearizing 2D integer coordinates, so x and y are combined into a single number that can be compared easily and has the property that a number is usually close to another if their x and y values are close.</p>

<hr />

<h3 id="interleave-bits-by-table-lookup">Interleave bits by table lookup</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">short</span> MortonTable256[<span style="color:#ff0;font-weight:bold">256</span>] =
{
  <span style="color:#ff0;font-weight:bold">0x0000</span>, <span style="color:#ff0;font-weight:bold">0x0001</span>, <span style="color:#ff0;font-weight:bold">0x0004</span>, <span style="color:#ff0;font-weight:bold">0x0005</span>, <span style="color:#ff0;font-weight:bold">0x0010</span>, <span style="color:#ff0;font-weight:bold">0x0011</span>, <span style="color:#ff0;font-weight:bold">0x0014</span>, <span style="color:#ff0;font-weight:bold">0x0015</span>,
  <span style="color:#ff0;font-weight:bold">0x0040</span>, <span style="color:#ff0;font-weight:bold">0x0041</span>, <span style="color:#ff0;font-weight:bold">0x0044</span>, <span style="color:#ff0;font-weight:bold">0x0045</span>, <span style="color:#ff0;font-weight:bold">0x0050</span>, <span style="color:#ff0;font-weight:bold">0x0051</span>, <span style="color:#ff0;font-weight:bold">0x0054</span>, <span style="color:#ff0;font-weight:bold">0x0055</span>,
  <span style="color:#ff0;font-weight:bold">0x0100</span>, <span style="color:#ff0;font-weight:bold">0x0101</span>, <span style="color:#ff0;font-weight:bold">0x0104</span>, <span style="color:#ff0;font-weight:bold">0x0105</span>, <span style="color:#ff0;font-weight:bold">0x0110</span>, <span style="color:#ff0;font-weight:bold">0x0111</span>, <span style="color:#ff0;font-weight:bold">0x0114</span>, <span style="color:#ff0;font-weight:bold">0x0115</span>,
  <span style="color:#ff0;font-weight:bold">0x0140</span>, <span style="color:#ff0;font-weight:bold">0x0141</span>, <span style="color:#ff0;font-weight:bold">0x0144</span>, <span style="color:#ff0;font-weight:bold">0x0145</span>, <span style="color:#ff0;font-weight:bold">0x0150</span>, <span style="color:#ff0;font-weight:bold">0x0151</span>, <span style="color:#ff0;font-weight:bold">0x0154</span>, <span style="color:#ff0;font-weight:bold">0x0155</span>,
  <span style="color:#ff0;font-weight:bold">0x0400</span>, <span style="color:#ff0;font-weight:bold">0x0401</span>, <span style="color:#ff0;font-weight:bold">0x0404</span>, <span style="color:#ff0;font-weight:bold">0x0405</span>, <span style="color:#ff0;font-weight:bold">0x0410</span>, <span style="color:#ff0;font-weight:bold">0x0411</span>, <span style="color:#ff0;font-weight:bold">0x0414</span>, <span style="color:#ff0;font-weight:bold">0x0415</span>,
  <span style="color:#ff0;font-weight:bold">0x0440</span>, <span style="color:#ff0;font-weight:bold">0x0441</span>, <span style="color:#ff0;font-weight:bold">0x0444</span>, <span style="color:#ff0;font-weight:bold">0x0445</span>, <span style="color:#ff0;font-weight:bold">0x0450</span>, <span style="color:#ff0;font-weight:bold">0x0451</span>, <span style="color:#ff0;font-weight:bold">0x0454</span>, <span style="color:#ff0;font-weight:bold">0x0455</span>,
  <span style="color:#ff0;font-weight:bold">0x0500</span>, <span style="color:#ff0;font-weight:bold">0x0501</span>, <span style="color:#ff0;font-weight:bold">0x0504</span>, <span style="color:#ff0;font-weight:bold">0x0505</span>, <span style="color:#ff0;font-weight:bold">0x0510</span>, <span style="color:#ff0;font-weight:bold">0x0511</span>, <span style="color:#ff0;font-weight:bold">0x0514</span>, <span style="color:#ff0;font-weight:bold">0x0515</span>,
  <span style="color:#ff0;font-weight:bold">0x0540</span>, <span style="color:#ff0;font-weight:bold">0x0541</span>, <span style="color:#ff0;font-weight:bold">0x0544</span>, <span style="color:#ff0;font-weight:bold">0x0545</span>, <span style="color:#ff0;font-weight:bold">0x0550</span>, <span style="color:#ff0;font-weight:bold">0x0551</span>, <span style="color:#ff0;font-weight:bold">0x0554</span>, <span style="color:#ff0;font-weight:bold">0x0555</span>,
  <span style="color:#ff0;font-weight:bold">0x1000</span>, <span style="color:#ff0;font-weight:bold">0x1001</span>, <span style="color:#ff0;font-weight:bold">0x1004</span>, <span style="color:#ff0;font-weight:bold">0x1005</span>, <span style="color:#ff0;font-weight:bold">0x1010</span>, <span style="color:#ff0;font-weight:bold">0x1011</span>, <span style="color:#ff0;font-weight:bold">0x1014</span>, <span style="color:#ff0;font-weight:bold">0x1015</span>,
  <span style="color:#ff0;font-weight:bold">0x1040</span>, <span style="color:#ff0;font-weight:bold">0x1041</span>, <span style="color:#ff0;font-weight:bold">0x1044</span>, <span style="color:#ff0;font-weight:bold">0x1045</span>, <span style="color:#ff0;font-weight:bold">0x1050</span>, <span style="color:#ff0;font-weight:bold">0x1051</span>, <span style="color:#ff0;font-weight:bold">0x1054</span>, <span style="color:#ff0;font-weight:bold">0x1055</span>,
  <span style="color:#ff0;font-weight:bold">0x1100</span>, <span style="color:#ff0;font-weight:bold">0x1101</span>, <span style="color:#ff0;font-weight:bold">0x1104</span>, <span style="color:#ff0;font-weight:bold">0x1105</span>, <span style="color:#ff0;font-weight:bold">0x1110</span>, <span style="color:#ff0;font-weight:bold">0x1111</span>, <span style="color:#ff0;font-weight:bold">0x1114</span>, <span style="color:#ff0;font-weight:bold">0x1115</span>,
  <span style="color:#ff0;font-weight:bold">0x1140</span>, <span style="color:#ff0;font-weight:bold">0x1141</span>, <span style="color:#ff0;font-weight:bold">0x1144</span>, <span style="color:#ff0;font-weight:bold">0x1145</span>, <span style="color:#ff0;font-weight:bold">0x1150</span>, <span style="color:#ff0;font-weight:bold">0x1151</span>, <span style="color:#ff0;font-weight:bold">0x1154</span>, <span style="color:#ff0;font-weight:bold">0x1155</span>,
  <span style="color:#ff0;font-weight:bold">0x1400</span>, <span style="color:#ff0;font-weight:bold">0x1401</span>, <span style="color:#ff0;font-weight:bold">0x1404</span>, <span style="color:#ff0;font-weight:bold">0x1405</span>, <span style="color:#ff0;font-weight:bold">0x1410</span>, <span style="color:#ff0;font-weight:bold">0x1411</span>, <span style="color:#ff0;font-weight:bold">0x1414</span>, <span style="color:#ff0;font-weight:bold">0x1415</span>,
  <span style="color:#ff0;font-weight:bold">0x1440</span>, <span style="color:#ff0;font-weight:bold">0x1441</span>, <span style="color:#ff0;font-weight:bold">0x1444</span>, <span style="color:#ff0;font-weight:bold">0x1445</span>, <span style="color:#ff0;font-weight:bold">0x1450</span>, <span style="color:#ff0;font-weight:bold">0x1451</span>, <span style="color:#ff0;font-weight:bold">0x1454</span>, <span style="color:#ff0;font-weight:bold">0x1455</span>,
  <span style="color:#ff0;font-weight:bold">0x1500</span>, <span style="color:#ff0;font-weight:bold">0x1501</span>, <span style="color:#ff0;font-weight:bold">0x1504</span>, <span style="color:#ff0;font-weight:bold">0x1505</span>, <span style="color:#ff0;font-weight:bold">0x1510</span>, <span style="color:#ff0;font-weight:bold">0x1511</span>, <span style="color:#ff0;font-weight:bold">0x1514</span>, <span style="color:#ff0;font-weight:bold">0x1515</span>,
  <span style="color:#ff0;font-weight:bold">0x1540</span>, <span style="color:#ff0;font-weight:bold">0x1541</span>, <span style="color:#ff0;font-weight:bold">0x1544</span>, <span style="color:#ff0;font-weight:bold">0x1545</span>, <span style="color:#ff0;font-weight:bold">0x1550</span>, <span style="color:#ff0;font-weight:bold">0x1551</span>, <span style="color:#ff0;font-weight:bold">0x1554</span>, <span style="color:#ff0;font-weight:bold">0x1555</span>,
  <span style="color:#ff0;font-weight:bold">0x4000</span>, <span style="color:#ff0;font-weight:bold">0x4001</span>, <span style="color:#ff0;font-weight:bold">0x4004</span>, <span style="color:#ff0;font-weight:bold">0x4005</span>, <span style="color:#ff0;font-weight:bold">0x4010</span>, <span style="color:#ff0;font-weight:bold">0x4011</span>, <span style="color:#ff0;font-weight:bold">0x4014</span>, <span style="color:#ff0;font-weight:bold">0x4015</span>,
  <span style="color:#ff0;font-weight:bold">0x4040</span>, <span style="color:#ff0;font-weight:bold">0x4041</span>, <span style="color:#ff0;font-weight:bold">0x4044</span>, <span style="color:#ff0;font-weight:bold">0x4045</span>, <span style="color:#ff0;font-weight:bold">0x4050</span>, <span style="color:#ff0;font-weight:bold">0x4051</span>, <span style="color:#ff0;font-weight:bold">0x4054</span>, <span style="color:#ff0;font-weight:bold">0x4055</span>,
  <span style="color:#ff0;font-weight:bold">0x4100</span>, <span style="color:#ff0;font-weight:bold">0x4101</span>, <span style="color:#ff0;font-weight:bold">0x4104</span>, <span style="color:#ff0;font-weight:bold">0x4105</span>, <span style="color:#ff0;font-weight:bold">0x4110</span>, <span style="color:#ff0;font-weight:bold">0x4111</span>, <span style="color:#ff0;font-weight:bold">0x4114</span>, <span style="color:#ff0;font-weight:bold">0x4115</span>,
  <span style="color:#ff0;font-weight:bold">0x4140</span>, <span style="color:#ff0;font-weight:bold">0x4141</span>, <span style="color:#ff0;font-weight:bold">0x4144</span>, <span style="color:#ff0;font-weight:bold">0x4145</span>, <span style="color:#ff0;font-weight:bold">0x4150</span>, <span style="color:#ff0;font-weight:bold">0x4151</span>, <span style="color:#ff0;font-weight:bold">0x4154</span>, <span style="color:#ff0;font-weight:bold">0x4155</span>,
  <span style="color:#ff0;font-weight:bold">0x4400</span>, <span style="color:#ff0;font-weight:bold">0x4401</span>, <span style="color:#ff0;font-weight:bold">0x4404</span>, <span style="color:#ff0;font-weight:bold">0x4405</span>, <span style="color:#ff0;font-weight:bold">0x4410</span>, <span style="color:#ff0;font-weight:bold">0x4411</span>, <span style="color:#ff0;font-weight:bold">0x4414</span>, <span style="color:#ff0;font-weight:bold">0x4415</span>,
  <span style="color:#ff0;font-weight:bold">0x4440</span>, <span style="color:#ff0;font-weight:bold">0x4441</span>, <span style="color:#ff0;font-weight:bold">0x4444</span>, <span style="color:#ff0;font-weight:bold">0x4445</span>, <span style="color:#ff0;font-weight:bold">0x4450</span>, <span style="color:#ff0;font-weight:bold">0x4451</span>, <span style="color:#ff0;font-weight:bold">0x4454</span>, <span style="color:#ff0;font-weight:bold">0x4455</span>,
  <span style="color:#ff0;font-weight:bold">0x4500</span>, <span style="color:#ff0;font-weight:bold">0x4501</span>, <span style="color:#ff0;font-weight:bold">0x4504</span>, <span style="color:#ff0;font-weight:bold">0x4505</span>, <span style="color:#ff0;font-weight:bold">0x4510</span>, <span style="color:#ff0;font-weight:bold">0x4511</span>, <span style="color:#ff0;font-weight:bold">0x4514</span>, <span style="color:#ff0;font-weight:bold">0x4515</span>,
  <span style="color:#ff0;font-weight:bold">0x4540</span>, <span style="color:#ff0;font-weight:bold">0x4541</span>, <span style="color:#ff0;font-weight:bold">0x4544</span>, <span style="color:#ff0;font-weight:bold">0x4545</span>, <span style="color:#ff0;font-weight:bold">0x4550</span>, <span style="color:#ff0;font-weight:bold">0x4551</span>, <span style="color:#ff0;font-weight:bold">0x4554</span>, <span style="color:#ff0;font-weight:bold">0x4555</span>,
  <span style="color:#ff0;font-weight:bold">0x5000</span>, <span style="color:#ff0;font-weight:bold">0x5001</span>, <span style="color:#ff0;font-weight:bold">0x5004</span>, <span style="color:#ff0;font-weight:bold">0x5005</span>, <span style="color:#ff0;font-weight:bold">0x5010</span>, <span style="color:#ff0;font-weight:bold">0x5011</span>, <span style="color:#ff0;font-weight:bold">0x5014</span>, <span style="color:#ff0;font-weight:bold">0x5015</span>,
  <span style="color:#ff0;font-weight:bold">0x5040</span>, <span style="color:#ff0;font-weight:bold">0x5041</span>, <span style="color:#ff0;font-weight:bold">0x5044</span>, <span style="color:#ff0;font-weight:bold">0x5045</span>, <span style="color:#ff0;font-weight:bold">0x5050</span>, <span style="color:#ff0;font-weight:bold">0x5051</span>, <span style="color:#ff0;font-weight:bold">0x5054</span>, <span style="color:#ff0;font-weight:bold">0x5055</span>,
  <span style="color:#ff0;font-weight:bold">0x5100</span>, <span style="color:#ff0;font-weight:bold">0x5101</span>, <span style="color:#ff0;font-weight:bold">0x5104</span>, <span style="color:#ff0;font-weight:bold">0x5105</span>, <span style="color:#ff0;font-weight:bold">0x5110</span>, <span style="color:#ff0;font-weight:bold">0x5111</span>, <span style="color:#ff0;font-weight:bold">0x5114</span>, <span style="color:#ff0;font-weight:bold">0x5115</span>,
  <span style="color:#ff0;font-weight:bold">0x5140</span>, <span style="color:#ff0;font-weight:bold">0x5141</span>, <span style="color:#ff0;font-weight:bold">0x5144</span>, <span style="color:#ff0;font-weight:bold">0x5145</span>, <span style="color:#ff0;font-weight:bold">0x5150</span>, <span style="color:#ff0;font-weight:bold">0x5151</span>, <span style="color:#ff0;font-weight:bold">0x5154</span>, <span style="color:#ff0;font-weight:bold">0x5155</span>,
  <span style="color:#ff0;font-weight:bold">0x5400</span>, <span style="color:#ff0;font-weight:bold">0x5401</span>, <span style="color:#ff0;font-weight:bold">0x5404</span>, <span style="color:#ff0;font-weight:bold">0x5405</span>, <span style="color:#ff0;font-weight:bold">0x5410</span>, <span style="color:#ff0;font-weight:bold">0x5411</span>, <span style="color:#ff0;font-weight:bold">0x5414</span>, <span style="color:#ff0;font-weight:bold">0x5415</span>,
  <span style="color:#ff0;font-weight:bold">0x5440</span>, <span style="color:#ff0;font-weight:bold">0x5441</span>, <span style="color:#ff0;font-weight:bold">0x5444</span>, <span style="color:#ff0;font-weight:bold">0x5445</span>, <span style="color:#ff0;font-weight:bold">0x5450</span>, <span style="color:#ff0;font-weight:bold">0x5451</span>, <span style="color:#ff0;font-weight:bold">0x5454</span>, <span style="color:#ff0;font-weight:bold">0x5455</span>,
  <span style="color:#ff0;font-weight:bold">0x5500</span>, <span style="color:#ff0;font-weight:bold">0x5501</span>, <span style="color:#ff0;font-weight:bold">0x5504</span>, <span style="color:#ff0;font-weight:bold">0x5505</span>, <span style="color:#ff0;font-weight:bold">0x5510</span>, <span style="color:#ff0;font-weight:bold">0x5511</span>, <span style="color:#ff0;font-weight:bold">0x5514</span>, <span style="color:#ff0;font-weight:bold">0x5515</span>,
  <span style="color:#ff0;font-weight:bold">0x5540</span>, <span style="color:#ff0;font-weight:bold">0x5541</span>, <span style="color:#ff0;font-weight:bold">0x5544</span>, <span style="color:#ff0;font-weight:bold">0x5545</span>, <span style="color:#ff0;font-weight:bold">0x5550</span>, <span style="color:#ff0;font-weight:bold">0x5551</span>, <span style="color:#ff0;font-weight:bold">0x5554</span>, <span style="color:#ff0;font-weight:bold">0x5555</span>
};

<span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">short</span> x; <span style="color:#007f7f">// Interleave bits of x and y, so that all of the
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">short</span> y; <span style="color:#007f7f">// bits of x are in the even positions and y in the odd;
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> z;   <span style="color:#007f7f">// z gets the resulting 32-bit Morton Number.
</span><span style="color:#007f7f"></span>
z = MortonTable256[y &gt;&gt; <span style="color:#ff0;font-weight:bold">8</span>]   &lt;&lt; <span style="color:#ff0;font-weight:bold">17</span> |
    MortonTable256[x &gt;&gt; <span style="color:#ff0;font-weight:bold">8</span>]   &lt;&lt; <span style="color:#ff0;font-weight:bold">16</span> |
    MortonTable256[y &amp; <span style="color:#ff0;font-weight:bold">0xFF</span>] &lt;&lt;  <span style="color:#ff0;font-weight:bold">1</span> |
    MortonTable256[x &amp; <span style="color:#ff0;font-weight:bold">0xFF</span>];</code></pre></div>
<p>For more speed, use an additional table with values that are MortonTable256 pre-shifted one bit to the left. This second table could then be used for the y lookups, thus reducing the operations by two, but almost doubling the memory required. Extending this same idea, four tables could be used, with two of them pre-shifted by 16 to the left of the previous two, so that we would only need 11 operations total.</p>

<hr />

<h3 id="interleave-bits-with-64-bit-multiply">Interleave bits with 64-bit multiply</h3>

<p>In 11 operations, this version interleaves bits of two bytes (rather than shorts, as in the other versions), but many of the operations are 64-bit multiplies so it isn&rsquo;t appropriate for all machines. The input parameters, x and y, should be less than 256.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">char</span> x;  <span style="color:#007f7f">// Interleave bits of (8-bit) x and y, so that all of the
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">char</span> y;  <span style="color:#007f7f">// bits of x are in the even positions and y in the odd;
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">short</span> z; <span style="color:#007f7f">// z gets the resulting 16-bit Morton Number.
</span><span style="color:#007f7f"></span>
z = ((x * <span style="color:#ff0;font-weight:bold">0x0101010101010101ULL</span> &amp; <span style="color:#ff0;font-weight:bold">0x8040201008040201ULL</span>) *
     <span style="color:#ff0;font-weight:bold">0x0102040810204081ULL</span> &gt;&gt; <span style="color:#ff0;font-weight:bold">49</span>) &amp; <span style="color:#ff0;font-weight:bold">0x5555</span> |
    ((y * <span style="color:#ff0;font-weight:bold">0x0101010101010101ULL</span> &amp; <span style="color:#ff0;font-weight:bold">0x8040201008040201ULL</span>) *
     <span style="color:#ff0;font-weight:bold">0x0102040810204081ULL</span> &gt;&gt; <span style="color:#ff0;font-weight:bold">48</span>) &amp; <span style="color:#ff0;font-weight:bold">0xAAAA</span>;</code></pre></div>
<p>Holger Bettag was inspired to suggest this technique on October 10, 2004 after reading the multiply-based bit reversals here.</p>

<hr />

<h3 id="interleave-bits-by-binary-magic-numbers">Interleave bits by Binary Magic Numbers</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> B[] = {<span style="color:#ff0;font-weight:bold">0x55555555</span>, <span style="color:#ff0;font-weight:bold">0x33333333</span>, <span style="color:#ff0;font-weight:bold">0x0F0F0F0F</span>, <span style="color:#ff0;font-weight:bold">0x00FF00FF</span>};
<span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> S[] = {<span style="color:#ff0;font-weight:bold">1</span>, <span style="color:#ff0;font-weight:bold">2</span>, <span style="color:#ff0;font-weight:bold">4</span>, <span style="color:#ff0;font-weight:bold">8</span>};

<span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> x; <span style="color:#007f7f">// Interleave lower 16 bits of x and y, so the bits of x
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> y; <span style="color:#007f7f">// are in the even positions and bits from y in the odd;
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> z; <span style="color:#007f7f">// z gets the resulting 32-bit Morton Number.  
</span><span style="color:#007f7f"></span>                <span style="color:#007f7f">// x and y must initially be less than 65536.
</span><span style="color:#007f7f"></span>
x = (x | (x &lt;&lt; S[<span style="color:#ff0;font-weight:bold">3</span>])) &amp; B[<span style="color:#ff0;font-weight:bold">3</span>];
x = (x | (x &lt;&lt; S[<span style="color:#ff0;font-weight:bold">2</span>])) &amp; B[<span style="color:#ff0;font-weight:bold">2</span>];
x = (x | (x &lt;&lt; S[<span style="color:#ff0;font-weight:bold">1</span>])) &amp; B[<span style="color:#ff0;font-weight:bold">1</span>];
x = (x | (x &lt;&lt; S[<span style="color:#ff0;font-weight:bold">0</span>])) &amp; B[<span style="color:#ff0;font-weight:bold">0</span>];

y = (y | (y &lt;&lt; S[<span style="color:#ff0;font-weight:bold">3</span>])) &amp; B[<span style="color:#ff0;font-weight:bold">3</span>];
y = (y | (y &lt;&lt; S[<span style="color:#ff0;font-weight:bold">2</span>])) &amp; B[<span style="color:#ff0;font-weight:bold">2</span>];
y = (y | (y &lt;&lt; S[<span style="color:#ff0;font-weight:bold">1</span>])) &amp; B[<span style="color:#ff0;font-weight:bold">1</span>];
y = (y | (y &lt;&lt; S[<span style="color:#ff0;font-weight:bold">0</span>])) &amp; B[<span style="color:#ff0;font-weight:bold">0</span>];

z = x | (y &lt;&lt; <span style="color:#ff0;font-weight:bold">1</span>);</code></pre></div>
<hr />

<h3 id="determine-if-a-word-has-a-zero-byte">Determine if a word has a zero byte</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#007f7f">// Fewer operations:
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> v; <span style="color:#007f7f">// 32-bit word to check if any 8-bit byte in it is 0
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">bool</span> hasZeroByte = ~((((v &amp; <span style="color:#ff0;font-weight:bold">0x7F7F7F7F</span>) + <span style="color:#ff0;font-weight:bold">0x7F7F7F7F</span>) | v) | <span style="color:#ff0;font-weight:bold">0x7F7F7F7F</span>);</code></pre></div>
<p>The code above may be useful when doing a fast string copy in which a word is copied at a time; it uses 5 operations. On the other hand, testing for a null byte in the obvious ways (which follow) have at least 7 operations (when counted in the most sparing way), and at most 12.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#007f7f">// More operations:
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">bool</span> hasNoZeroByte = ((v &amp; <span style="color:#ff0;font-weight:bold">0xff</span>) &amp;&amp; (v &amp; <span style="color:#ff0;font-weight:bold">0xff00</span>) &amp;&amp; (v &amp; <span style="color:#ff0;font-weight:bold">0xff0000</span>) &amp;&amp; (v &amp; <span style="color:#ff0;font-weight:bold">0xff000000</span>))
<span style="color:#007f7f">// OR:
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">char</span> * p = (<span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">char</span> *) &amp;v;  
<span style="color:#fff;font-weight:bold">bool</span> hasNoZeroByte = *p &amp;&amp; *(p + <span style="color:#ff0;font-weight:bold">1</span>) &amp;&amp; *(p + <span style="color:#ff0;font-weight:bold">2</span>) &amp;&amp; *(p + <span style="color:#ff0;font-weight:bold">3</span>);</code></pre></div>
<p>The code at the beginning of this section (labeled &ldquo;Fewer operations&rdquo;) works by first zeroing the high bits of the 4 bytes in the word. Subsequently, it adds a number that will result in an overflow to the high bit of a byte if any of the low bits were initialy set. Next the high bits of the original word are ORed with these values; thus, the high bit of a byte is set iff any bit in the byte was set. Finally, we determine if any of these high bits are zero by ORing with ones everywhere except the high bits and inverting the result. Extending to 64 bits is trivial; simply increase the constants to be 0x7F7F7F7F7F7F7F7F.</p>

<p>For an additional improvement, a fast pretest that requires only 4 operations may be performed to determine if the word <em>may</em> have a zero byte. The test also returns true if the high byte is 0x80, so there are occasional false positives, but the slower and more reliable version above may then be used on candidates for an overall increase in speed with correct output.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">bool</span> hasZeroByte = ((v + <span style="color:#ff0;font-weight:bold">0x7efefeff</span>) ^ ~v) &amp; <span style="color:#ff0;font-weight:bold">0x81010100</span>;
<span style="color:#fff;font-weight:bold">if</span> (hasZeroByte) <span style="color:#007f7f">// or may just have 0x80 in the high byte
</span><span style="color:#007f7f"></span>{
  hasZeroByte = ~((((v &amp; <span style="color:#ff0;font-weight:bold">0x7F7F7F7F</span>) + <span style="color:#ff0;font-weight:bold">0x7F7F7F7F</span>) | v) | <span style="color:#ff0;font-weight:bold">0x7F7F7F7F</span>);
}</code></pre></div>
<p>There is yet a faster method — use <a href="#HasLessInWord"><code>hasless</code></a>(v, 1), which is defined below; it works in 4 operations and requires no subsquent verification. It simplifies to</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#0f0;font-weight:bold">#define haszero(v) (((v) - 0x01010101UL) &amp; ~(v) &amp; 0x80808080UL)</span></code></pre></div>
<p>The subexpression (v - 0x01010101UL), evaluates to a high bit set in any byte whenever the corresponding byte in v is zero or greater than 0x80. The sub-expression ~v &amp; 0x80808080UL evaluates to high bits set in bytes where the byte of v doesn&rsquo;t have its high bit set (so the byte was less than 0x80). Finally, by ANDing these two sub-expressions the result is the high bits set where the bytes in v were zero, since the high bits set due to a value greater than 0x80 in the first sub-expression are masked off by the second.</p>

<p>Paul Messmer suggested the fast pretest improvement on October 2, 2004. Juha Järvi later suggested <code>hasless(v, 1)</code> on April 6, 2005, which he found on <a href="http://www.azillionmonkeys.com/qed/asmexample.html">Paul Hsieh&rsquo;s Assembly Lab</a>; previously it was written in a newsgroup post on April 27, 1987 by Alan Mycroft.</p>

<hr />

<h3 id="determine-if-a-word-has-a-byte-equal-to-n">Determine if a word has a byte equal to n</h3>

<p>We may want to know if any byte in a word has a specific value. To do so, we can XOR the value to test with a word that has been filled with the byte values in which we&rsquo;re interested. Because XORing a value with itself results in a zero byte and nonzero otherwise, we can pass the result to <code>haszero</code>.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#0f0;font-weight:bold">#define hasvalue(x,n) \
</span><span style="color:#0f0;font-weight:bold"></span>(haszero((x) ^ (~<span style="color:#ff0;font-weight:bold">0UL</span>/<span style="color:#ff0;font-weight:bold">255</span> * (n))))</code></pre></div>
<p>Stephen M Bennet suggested this on December 13, 2009 after reading the entry for <code>haszero</code>.</p>

<hr />

<h3 id="determine-if-a-word-has-a-byte-less-than-n">Determine if a word has a byte less than n</h3>

<p>Test if a word x contains an unsigned byte with value &lt; n. Specifically for n=1, it can be used to find a 0-byte by examining one long at a time, or any byte by XORing x with a mask first. Uses 4 arithmetic/logical operations when n is constant.</p>

<p>Requirements: x&gt;=0; 0&lt;=n&lt;=128</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#0f0;font-weight:bold">#define hasless(x,n) (((x)-~0UL/255*(n))&amp;~(x)&amp;~0UL/255*128)</span></code></pre></div>
<p>To count the number of bytes in x that are less than n in 7 operations, use</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#0f0;font-weight:bold">#define countless(x,n) \
</span><span style="color:#0f0;font-weight:bold"></span>(((~<span style="color:#ff0;font-weight:bold">0UL</span>/<span style="color:#ff0;font-weight:bold">255</span>*(<span style="color:#ff0;font-weight:bold">127</span>+(n))-((x)&amp;~<span style="color:#ff0;font-weight:bold">0UL</span>/<span style="color:#ff0;font-weight:bold">255</span>*<span style="color:#ff0;font-weight:bold">127</span>))&amp;~(x)&amp;~<span style="color:#ff0;font-weight:bold">0UL</span>/<span style="color:#ff0;font-weight:bold">255</span>*<span style="color:#ff0;font-weight:bold">128</span>)/<span style="color:#ff0;font-weight:bold">128</span>%<span style="color:#ff0;font-weight:bold">255</span>)</code></pre></div>
<p>Juha Järvi sent this clever technique to me on April 6, 2005. The <code>countless</code> macro was added by Sean Anderson on April 10, 2005, inspired by Juha&rsquo;s <code>countmore</code>, below.</p>

<hr />

<h3 id="determine-if-a-word-has-a-byte-greater-than-n">Determine if a word has a byte greater than n</h3>

<p>Test if a word x contains an unsigned byte with value &gt; n. Uses 3 arithmetic/logical operations when n is constant.</p>

<p>Requirements: x&gt;=0; 0&lt;=n&lt;=127</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#0f0;font-weight:bold">#define hasmore(x,n) (((x)+~0UL/255*(127-(n))|(x))&amp;~0UL/255*128)</span></code></pre></div>
<p>To count the number of bytes in x that are more than n in 6 operations, use:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#0f0;font-weight:bold">#define countmore(x,n) \
</span><span style="color:#0f0;font-weight:bold"></span>(((((x)&amp;~<span style="color:#ff0;font-weight:bold">0UL</span>/<span style="color:#ff0;font-weight:bold">255</span>*<span style="color:#ff0;font-weight:bold">127</span>)+~<span style="color:#ff0;font-weight:bold">0UL</span>/<span style="color:#ff0;font-weight:bold">255</span>*(<span style="color:#ff0;font-weight:bold">127</span>-(n))|(x))&amp;~<span style="color:#ff0;font-weight:bold">0UL</span>/<span style="color:#ff0;font-weight:bold">255</span>*<span style="color:#ff0;font-weight:bold">128</span>)/<span style="color:#ff0;font-weight:bold">128</span>%<span style="color:#ff0;font-weight:bold">255</span>)</code></pre></div>
<p>The macro <code>hasmore</code> was suggested by Juha Järvi on April 6, 2005, and he added <code>countmore</code> on April 8, 2005.</p>

<hr />

<h3 id="determine-if-a-word-has-a-byte-between-m-and-n">Determine if a word has a byte between m and n</h3>

<p>When m &lt; n, this technique tests if a word x contains an unsigned byte value, such that m &lt; value &lt; n. It uses 7 arithmetic/logical operations when n and m are constant.</p>

<p>Note: Bytes that equal n can be reported by <code>likelyhasbetween</code> as false positives, so this should be checked by character if a certain result is needed.</p>

<p>Requirements: x&gt;=0; 0&lt;=m&lt;=127; 0&lt;=n&lt;=128</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#0f0;font-weight:bold">#define likelyhasbetween(x,m,n) \
</span><span style="color:#0f0;font-weight:bold"></span>((((x)-~<span style="color:#ff0;font-weight:bold">0UL</span>/<span style="color:#ff0;font-weight:bold">255</span>*(n))&amp;~(x)&amp;((x)&amp;~<span style="color:#ff0;font-weight:bold">0UL</span>/<span style="color:#ff0;font-weight:bold">255</span>*<span style="color:#ff0;font-weight:bold">127</span>)+~<span style="color:#ff0;font-weight:bold">0UL</span>/<span style="color:#ff0;font-weight:bold">255</span>*(<span style="color:#ff0;font-weight:bold">127</span>-(m)))&amp;~<span style="color:#ff0;font-weight:bold">0UL</span>/<span style="color:#ff0;font-weight:bold">255</span>*<span style="color:#ff0;font-weight:bold">128</span>)</code></pre></div>
<p>This technique would be suitable for a fast pretest. A variation that takes one more operation (8 total for constant m and n) but provides the exact answer is:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#0f0;font-weight:bold">#define hasbetween(x,m,n) \
</span><span style="color:#0f0;font-weight:bold"></span>((~<span style="color:#ff0;font-weight:bold">0UL</span>/<span style="color:#ff0;font-weight:bold">255</span>*(<span style="color:#ff0;font-weight:bold">127</span>+(n))-((x)&amp;~<span style="color:#ff0;font-weight:bold">0UL</span>/<span style="color:#ff0;font-weight:bold">255</span>*<span style="color:#ff0;font-weight:bold">127</span>)&amp;~(x)&amp;((x)&amp;~<span style="color:#ff0;font-weight:bold">0UL</span>/<span style="color:#ff0;font-weight:bold">255</span>*<span style="color:#ff0;font-weight:bold">127</span>)+~<span style="color:#ff0;font-weight:bold">0UL</span>/<span style="color:#ff0;font-weight:bold">255</span>*(<span style="color:#ff0;font-weight:bold">127</span>-(m)))&amp;~<span style="color:#ff0;font-weight:bold">0UL</span>/<span style="color:#ff0;font-weight:bold">255</span>*<span style="color:#ff0;font-weight:bold">128</span>)</code></pre></div>
<p>To count the number of bytes in x that are between m and n (exclusive) in 10 operations, use:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#0f0;font-weight:bold">#define countbetween(x,m,n) (hasbetween(x,m,n)/128%255)</span></code></pre></div>
<p>Juha Järvi suggested <code>likelyhasbetween</code> on April 6, 2005. From there, Sean Anderson created <code>hasbetween</code> and <code>countbetween</code> on April 10, 2005.</p>

<hr />

<h3 id="compute-the-lexicographically-next-bit-permutation">Compute the lexicographically next bit permutation</h3>

<p>Suppose we have a pattern of N bits set to 1 in an integer and we want the next permutation of N 1 bits in a lexicographical sense. For example, if N is 3 and the bit pattern is 00010011, the next patterns would be 00010101, 00010110, 00011001,00011010, 00011100, 00100011, and so forth. The following is a fast way to compute the next permutation.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> v; <span style="color:#007f7f">// current permutation of bits
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> w; <span style="color:#007f7f">// next permutation of bits
</span><span style="color:#007f7f"></span>
<span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> t = v | (v - <span style="color:#ff0;font-weight:bold">1</span>); <span style="color:#007f7f">// t gets v&#39;s least significant 0 bits set to 1
</span><span style="color:#007f7f">// Next set to 1 the most significant bit to change, 
</span><span style="color:#007f7f">// set to 0 the least significant ones, and add the necessary 1 bits.
</span><span style="color:#007f7f"></span>w = (t + <span style="color:#ff0;font-weight:bold">1</span>) | (((~t &amp; -~t) - <span style="color:#ff0;font-weight:bold">1</span>) &gt;&gt; (__builtin_ctz(v) + <span style="color:#ff0;font-weight:bold">1</span>));  </code></pre></div>
<p>The __builtin_ctz(v) GNU C compiler intrinsic for x86 CPUs returns the number of trailing zeros. If you are using Microsoft compilers for x86, the intrinsic is _BitScanForward. These both emit a bsf instruction, but equivalents may be available for other architectures. If not, then consider using one of the methods for counting the consecutive zero bits mentioned earlier.</p>

<p>Here is another version that tends to be slower because of its division operator, but it does not require counting the trailing zeros.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> t = (v | (v - <span style="color:#ff0;font-weight:bold">1</span>)) + <span style="color:#ff0;font-weight:bold">1</span>;  
w = t | ((((t &amp; -t) / (v &amp; -v)) &gt;&gt; <span style="color:#ff0;font-weight:bold">1</span>) - <span style="color:#ff0;font-weight:bold">1</span>);  </code></pre></div>
<p>Thanks to Dario Sneidermanis of Argentina, who provided this on November 28, 2009.</p>

<p><a href="http://webhostingrating.com/libs/bithacks-be">A Belorussian translation</a> (provided by <a href="http://webhostingrating.com/">Webhostingrating</a>) is available.</p>

<p><a href="https://graphics.stanford.edu/~seander/bithacks.html">Original Page</a></p>

      </div>

      <footer>
        

<section class="see-also">
  
    <h3>See also in Getting Started</h3>
    
    
    
      <nav>
        <ul>
        
        
          
        
          
            <li>
              <a href="https://d-dandrew.github.io/en/posts/the-star/">The Star</a>
            </li>
          
        
          
            <li>
              <a href="https://d-dandrew.github.io/en/posts/how-to-ask-questions-the-smart-ways/">How To Ask Questions The Smart Way</a>
            </li>
          
        
          
            <li>
              <a href="https://d-dandrew.github.io/en/posts/the-last-question/">The Last Question</a>
            </li>
          
        
        </ul>
      </nav>
    
  
    <h3>See also in Development</h3>
    
    
    
      <nav>
        <ul>
        
        
          
        
        </ul>
      </nav>
    
  
</section>


        
      </footer>
    </article>

  </section>

      </div>

      <footer class="footer">
  <section class="container">
    
      <p>Run fast</p>
    
     © 2019
    
       · 
      Powered by <a href="https://gohugo.io/">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/">Coder</a>.
    
    
  </section>
</footer>

    </main>

    

  </body>

</html>
